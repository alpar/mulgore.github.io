<!DOCTYPE html>
<html lang=zh>
<head>
    <meta charset="utf-8">
    <script>
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "//hm.baidu.com/hm.js?1d25f2a1077359921740604b649a2dea";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
    </script>
    
    <title>Mulgore</title>
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1" />
    <meta name="description" content="Mulgore FED learn managed website in China 挖掘互联网最优秀的前端技术，提供高效的自我驱动学习与管理服务。">
<meta property="og:type" content="website">
<meta property="og:title" content="Mulgore">
<meta property="og:url" content="https://mulgore.github.io/page/3/index.html">
<meta property="og:site_name" content="Mulgore">
<meta property="og:description" content="Mulgore FED learn managed website in China 挖掘互联网最优秀的前端技术，提供高效的自我驱动学习与管理服务。">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Mulgore">
<meta name="twitter:description" content="Mulgore FED learn managed website in China 挖掘互联网最优秀的前端技术，提供高效的自我驱动学习与管理服务。">
    

    

    

    <link rel="stylesheet" href="/vendor/font-awesome/css/font-awesome.min.css">
    <link rel="stylesheet" href="/vendor/open-sans/styles.css">
    <link rel="stylesheet" href="/vendor/source-code-pro/styles.css">

    <link rel="stylesheet" href="/css/style.css">

    <script src="/vendor/jquery/2.1.3/jquery.min.js"></script>
    
    
        <link rel="stylesheet" href="/vendor/fancybox/jquery.fancybox.css">
    
    
    
    

</head>

<body>
    <div id="container">
        <header id="header">
    <div id="header-main" class="header-inner">
        <div class="outer">
            <a href="/" id="logo">
                <i class="logo"></i>
                <span class="site-title">Mulgore</span>
            </a>
            <nav id="main-nav">
                
                    <a class="main-nav-link" href="/.">首页</a>
                
                    <a class="main-nav-link" href="/archives/index.html">温故而知新</a>
                
                    <a class="main-nav-link" href="/weekly/index.html">课多周刊</a>
                
                    <a class="main-nav-link" href="/lesson/index.html">实战课程</a>
                
                    <a class="main-nav-link" href="/contribute/index.html">投稿渠道</a>
                
                    <a class="main-nav-link" href="/about">关于我们</a>
                
            </nav>
            
                
                <nav id="sub-nav">
                    <div class="profile" id="profile-nav">
                        <a id="profile-anchor" href="javascript:;">
                            <img class="avatar" src="https://raw.githubusercontent.com/icepy/_posts/master/img/weixin.jpg" />
                            <i class="fa fa-caret-down"></i>
                        </a>
                    </div>
                </nav>
            
            <div id="search-form-wrap">

    <form class="search-form">
        <input type="text" class="ins-search-input search-form-input" placeholder="搜索" />
        <button type="submit" class="search-form-submit"></button>
    </form>
    <div class="ins-search">
    <div class="ins-search-mask"></div>
    <div class="ins-search-container">
        <div class="ins-input-wrapper">
            <input type="text" class="ins-search-input" placeholder="想要查找什么..." />
            <span class="ins-close ins-selectable"><i class="fa fa-times-circle"></i></span>
        </div>
        <div class="ins-section-wrapper">
            <div class="ins-section-container"></div>
        </div>
    </div>
</div>
<script>
(function (window) {
    var INSIGHT_CONFIG = {
        TRANSLATION: {
            POSTS: '文章',
            PAGES: '页面',
            CATEGORIES: '分类',
            TAGS: '标签',
            UNTITLED: '(未命名)',
        },
        ROOT_URL: '/',
        CONTENT_URL: '/content.json',
    };
    window.INSIGHT_CONFIG = INSIGHT_CONFIG;
})(window);
</script>
<script src="/js/insight.js"></script>

</div>
        </div>
    </div>
    <div id="main-nav-mobile" class="header-sub header-inner">
        <table class="menu outer">
            <tr>
                
                    <td><a class="main-nav-link" href="/.">首页</a></td>
                
                    <td><a class="main-nav-link" href="/archives/index.html">温故而知新</a></td>
                
                    <td><a class="main-nav-link" href="/weekly/index.html">课多周刊</a></td>
                
                    <td><a class="main-nav-link" href="/lesson/index.html">实战课程</a></td>
                
                    <td><a class="main-nav-link" href="/contribute/index.html">投稿渠道</a></td>
                
                    <td><a class="main-nav-link" href="/about">关于我们</a></td>
                
                <td>
                    
    <div class="search-form">
        <input type="text" class="ins-search-input search-form-input" placeholder="搜索" />
    </div>

                </td>
            </tr>
        </table>
    </div>
</header>

        <div class="outer">
            
                

<aside id="profile">
    <div class="inner profile-inner">
        <div class="base-info profile-block">
            <img id="avatar" src="https://raw.githubusercontent.com/icepy/_posts/master/img/weixin.jpg" />
            <h2 id="name">Mulgore</h2>
            <h3 id="title">欢迎关注mulgore组织运营的 [前端Talk] 公众号 -- 内容起于前端而不止于前端，探索技术深邃的灵光。</h3>
            <span id="location"><i class="fa fa-map-marker"></i>Beijing, China</span>
            <a id="follow" target="_blank" href="https://github.com/mulgore/">关注我</a>
        </div>
        <div class="article-info profile-block">
            <div class="article-info-block">
                31
                <span>文章</span>
            </div>
            <div class="article-info-block">
                8
                <span>标签</span>
            </div>
        </div>
        
        <div class="profile-block social-links">
            <table>
                <tr>
                    
                    <td><a href="http://github.com/mulgore" target="_blank" title="github"><i class="fa fa-github"></i></a></td>
                    
                    <td><a href="http://weibo.com/2455876310/" target="_blank" title="weibo"><i class="fa fa-weibo"></i></a></td>
                    
                </tr>
            </table>
        </div>
        
    </div>
</aside>

            
            <section id="main">
    <article id="post-swift-nsoperation" class="article article-type-post" itemscope itemprop="blogPost">
    <div class="article-inner">
        
        
        
            <header class="article-header">
                
    
        <h1 itemprop="name">
            <a class="article-title" href="/2015/12/29/swift-nsoperation/">NSOperation实现多线程（Swift）</a>
        </h1>
    

                <div class="article-meta">
                    
    <div class="article-date">
        <i class="fa fa-calendar"></i>
        <a href="/2015/12/29/swift-nsoperation/">
            <time datetime="2015-12-29T03:36:27.000Z" itemprop="datePublished">2015-12-29</time>
        </a>
    </div>


                    
                    
    <div class="article-tag">
        <i class="fa fa-tag"></i>
        <a class="tag-link" href="/tags/Swift/">Swift</a>
    </div>

                </div>
            </header>
        
        <div class="article-entry" itemprop="articleBody">
        
            
            <p>在上周，我用GCD去实践练习了一下多线程的使用，这周我将练习一种不同的多线程实现。</p>
<p>为了理解多线程你还需要理解一些概念性的东西，比如什么是串行，什么是并行，什么是临界区，什么是竞态条件。</p>
<p>关于这些概念，推荐一本书<a href="http://www.amazon.cn/gp/product/B0041859AI?psc=1&amp;ref_=oh_aui_detailpage_o07_s00" target="_blank" rel="external">《操作系统:精髓与设计原理》</a>，我且当你知道并且了解。</p>
<p><strong>前言论述</strong></p>
<p>在Foundation框架中提供了一个叫做<code>NSThread</code>的类，从名字上咱们就能看出，这是一个属于跟<code>线程</code>操作有关的类，没错。但是使用它来管理多个线程特别的繁琐，需要考虑竞态条件，需要锁等。于是，<code>NSOperation</code>和<code>NSOperationQueue</code>提供了更高级的封装，来很好的处理多个线程。</p>
<p><strong>实践练习</strong></p>
<p><code>NSOperation</code>是一个抽象类，所以不能直接使用它，但是它可以为子类提供有用且线程安全的建立状态，优先级，依赖和取消等操作。</p>
<ul>
<li>继承它来自己实现内部</li>
<li>使用<code>NSBlockOperation</code></li>
</ul>
<p><strong>注意：Swift中将不存在NSInvocationOperation相关APIs</strong></p>
<p><code>NSOperationQueue</code>则有些类似<code>线程池</code>，我们使用的<code>NSOperation</code>都需要添加到<code>NSOperationQueue</code>中，用来方便管理这些线程。</p>
<p><strong>它们应该是一对好兄弟</strong></p>
<p>NSOperation提供了<code>ready</code>，<code>cancelled</code>，<code>executing</code>， <code>finished</code>，这几个状态变化，可以通过<code>KVO</code>来通知改变这些状态，一般场景下你可能使用不到这些，除非你自己继承<code>NSOperation</code>来实现子类的方式来使用，你才需要管理这些状态。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> operation3 = <span class="type">NSBlockOperation</span>(block: &#123;</span><br><span class="line">    <span class="number">_</span> <span class="keyword">in</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"不用NSOperationQueue"</span>)</span><br><span class="line">&#125;)</span><br><span class="line">operation3.start()</span><br></pre></td></tr></table></figure>
<p><strong>添加依赖</strong></p>
<p>这个步骤在某些场景下非常有用，比如我先读取本地文件，然后根据文件来发送网络请求，这里可见网络请求是依赖于读取本地文件的。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">operation2.addDependency(operation1)</span><br></pre></td></tr></table></figure>
<p><em>注意事项：</em></p>
<ul>
<li>避免循环依赖，比如A依赖B，B又依赖A，那么恭喜你，死锁了。</li>
</ul>
<p><strong>执行</strong></p>
<p>如果你使用了<code>NSOperationQueue</code>，那么你将不需要手动调用<code>start</code>方法，因为队列会帮助我们调用start方法。</p>
<p><strong>取消</strong></p>
<p><code>NSOperation</code>允许你取消一个任务，跟GCD一样，如果任务正在执行，且是无法取消的，只能等待任务完成，调用<code>cancel</code>方法</p>
<p><strong>优先级</strong></p>
<p>通过设置<code>NSOperation</code>的<code>queuePriority</code>属性来提高某个<code>NSOperation</code>的优先级。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">enum</span> <span class="title">NSOperationQueuePriority</span> : <span class="title">Int</span> </span>&#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="type">VeryLow</span></span><br><span class="line">    <span class="keyword">case</span> <span class="type">Low</span></span><br><span class="line">    <span class="keyword">case</span> <span class="type">Normal</span></span><br><span class="line">    <span class="keyword">case</span> <span class="type">High</span></span><br><span class="line">    <span class="keyword">case</span> <span class="type">VeryHigh</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>例子</strong></p>
<p>读取本地文件和网络请求</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> queue:<span class="type">NSOperationQueue</span> = <span class="type">NSOperationQueue</span>()</span><br><span class="line"><span class="comment">//读取文件</span></span><br><span class="line"><span class="keyword">let</span> operation1:<span class="type">NSBlockOperation</span> = <span class="type">NSBlockOperation</span>(block: &#123;</span><br><span class="line">    <span class="number">_</span> <span class="keyword">in</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> path:<span class="type">String</span> = <span class="type">NSBundle</span>.mainBundle().pathForResource(<span class="string">"gulpfile"</span>, ofType: <span class="string">"js"</span>)!</span><br><span class="line">    <span class="keyword">let</span> manager:<span class="type">NSFileManager</span> = <span class="type">NSFileManager</span>.defaultManager()</span><br><span class="line">    <span class="keyword">let</span> isTrue:<span class="type">Bool</span> = manager.fileExistsAtPath(path)</span><br><span class="line">    <span class="keyword">if</span> isTrue &#123;</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"文件存在读取 \(path)"</span>)</span><br><span class="line">        <span class="keyword">do</span>&#123;</span><br><span class="line">            <span class="keyword">let</span> content:<span class="type">String</span> = <span class="keyword">try</span> <span class="type">NSString</span>(contentsOfURL: <span class="type">NSURL</span>(string: path)!, encoding: <span class="type">NSUTF8StringEncoding</span>) <span class="keyword">as</span> <span class="type">String</span></span><br><span class="line">            <span class="built_in">print</span>(<span class="string">"----------读取文件数据---------"</span>)</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">"\(content)"</span>)</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">"----------读取文件数据---------"</span>)</span><br><span class="line">        &#125;<span class="keyword">catch</span>&#123;</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">"读取错误"</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">//网络请求</span></span><br><span class="line"><span class="keyword">let</span> operation2:<span class="type">NSBlockOperation</span> = <span class="type">NSBlockOperation</span>(block: &#123;</span><br><span class="line">    <span class="number">_</span> <span class="keyword">in</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> url:<span class="type">String</span> = <span class="string">"https://github.com/icepy"</span></span><br><span class="line">    <span class="keyword">let</span> urlObject:<span class="type">NSURL</span> = <span class="type">NSURL</span>(string: url)!</span><br><span class="line">    <span class="keyword">let</span> request:<span class="type">NSURLRequest</span> = <span class="type">NSURLRequest</span>(<span class="type">URL</span>: urlObject)</span><br><span class="line">    <span class="keyword">var</span> response:<span class="type">NSURLResponse</span>?</span><br><span class="line">    <span class="keyword">do</span>&#123;</span><br><span class="line">        <span class="keyword">let</span> data:<span class="type">NSData</span> = <span class="keyword">try</span> <span class="type">NSURLConnection</span>.sendSynchronousRequest(request, returningResponse: &amp;response)</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">let</span> <span class="type">HTTPResponse</span> = response <span class="keyword">as</span>? <span class="type">NSHTTPURLResponse</span>&#123;</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">"状态码：\(HTTPResponse.statusCode)"</span>)</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">"============数据==========="</span>)</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">"\(data)"</span>)</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">"============数据==========="</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;<span class="keyword">catch</span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">//网络请求在读取文件之前</span></span><br><span class="line">operation2.addDependency(operation1)</span><br><span class="line"></span><br><span class="line">queue.addOperation(operation2)</span><br><span class="line">queue.addOperation(operation1)</span><br><span class="line"><span class="comment">//取消网络请求</span></span><br><span class="line">operation2.cancel()</span><br><span class="line"><span class="built_in">print</span>(<span class="string">"网络请求-同步不会阻塞显示这里"</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">"读取文件不会阻塞显示这里"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">//NSInvocationOperation 在 Swift不存在相关API</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> operation3 = <span class="type">NSBlockOperation</span>(block: &#123;</span><br><span class="line">    <span class="number">_</span> <span class="keyword">in</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"不用NSOperationQueue"</span>)</span><br><span class="line">&#125;)</span><br><span class="line">operation3.start()</span><br></pre></td></tr></table></figure>

        
        </div>
        <footer class="article-footer">
            <div class="share-container">

    <div class="jiathis_style">
    <span class="jiathis_txt">分享到：</span>
    <a class="jiathis_button_qzone">QQ空间</a>
    <a class="jiathis_button_tsina">新浪微博</a>
    <a class="jiathis_button_tqq">腾讯微博</a>
    <a class="jiathis_button_weixin">微信</a>
    <a href="http://www.jiathis.com/share" class="jiathis jiathis_txt jiathis_separator jtico jtico_jiathis" target="_blank">更多</a>
    <a class="jiathis_counter_style"></a>
</div>
<script type="text/javascript" src="http://v3.jiathis.com/code/jia.js" charset="utf-8"></script>
<style>
    .jiathis_style div:first-child:not(.jiadiv_01) {
        width: auto !important;
        border: none !important;
    }
    .jiathis_style .jiadiv_01 {
        margin: 10px 0;
        border-radius: 4px;
        border: #e1e1e1 solid 1px;
    }
    .jiathis_style .jiadiv_01 div:first-child {
        display: none;
    }
    .jiathis_style .jiadiv_02 {
        padding: 7px 0 !important;
    }
    .jiathis_style .jiadiv_02 .jiatitle {
        width: 85px;
        border: none;
        height: auto;
        margin: 3px 10px;
        padding: 6px 10px;
        border-radius: 4px;
    }
    .jiathis_style .jiadiv_02 .jiatitle:hover {
        border: none;
    }
    .jiathis_style .jiadiv_02 .jiatitle:nth-child(even) {
        margin-left: 0;
    }
    .jiathis_style .jtico:hover {
        opacity: 1;
    }
    .jiathis_style .ckepopBottom,
    .jiathis_style .centerBottom {
        width: auto !important;
        padding: 5px;
        background: #f7f7f7;
    }
</style>



</div>

            
    
        <a href="https://mulgore.github.io/2015/12/29/swift-nsoperation/#comments" class="article-comment-link ds-thread-count" data-thread-key="https://mulgore.github.io/2015/12/29/swift-nsoperation/">评论</a>
    

        </footer>
    </div>
    
</article>



    <article id="post-swift-gcd" class="article article-type-post" itemscope itemprop="blogPost">
    <div class="article-inner">
        
        
        
            <header class="article-header">
                
    
        <h1 itemprop="name">
            <a class="article-title" href="/2015/12/21/swift-gcd/">GCD（Swift）</a>
        </h1>
    

                <div class="article-meta">
                    
    <div class="article-date">
        <i class="fa fa-calendar"></i>
        <a href="/2015/12/21/swift-gcd/">
            <time datetime="2015-12-21T03:37:35.000Z" itemprop="datePublished">2015-12-21</time>
        </a>
    </div>


                    
                    
    <div class="article-tag">
        <i class="fa fa-tag"></i>
        <a class="tag-link" href="/tags/Swift/">Swift</a>
    </div>

                </div>
            </header>
        
        <div class="article-entry" itemprop="articleBody">
        
            
            <p>GCD是基于C API开发的一套库，苹果公司将它应用在（iOS或者OS X）上，为我们极大的方便来处理并发代码。</p>
<p><code>能为我们带来什么？</code></p>
<ul>
<li>GCD 能通过推迟昂贵计算任务并在后台运行它们来改善你的应用的响应性能。</li>
<li>GCD 提供一个易于使用的并发模型而不仅仅只是锁和线程，以帮助我们避开并发陷阱。</li>
<li>GCD 具有在常见模式（例如单例）上用更高性能的原语优化你的代码的潜在能力。</li>
</ul>
<p>为了理解GCD你还需要理解一些概念性的东西，比如什么是串行，什么是并行，什么是临界区，什么是竞态条件。</p>
<p>关于这些概念，推荐一本书<a href="http://www.amazon.cn/gp/product/B0041859AI?psc=1&amp;ref_=oh_aui_detailpage_o07_s00" target="_blank" rel="external">《操作系统:精髓与设计原理》</a>，我且当你知道并且了解。</p>
<p>Apple帮助我们定义好了两个常量来创建<code>串行</code>，<code>并行</code>的GCD任务：</p>
<ul>
<li>DISPATCH_QUEUE_SERIAL  串行</li>
<li>DISPATCH_QUEUE_CONCURRENT 并行</li>
</ul>
<p>利用<code>dispatch_..._...</code>可以轻松的创建这些任务，如图：</p>
<p><img src="https://raw.githubusercontent.com/icepy/_posts/master/img/GCDdebug.png" alt="GCD创建的多任务"></p>
<p>Demo例子基于Swift 2.1 Xcode 7.2 编写，可在此处<a href="https://github.com/icepy/_posts/blob/master/demo/GCD/GCD/ViewController.swift" target="_blank" rel="external">查看</a></p>
<p><strong>将一个block提交到主线程中执行</strong></p>
<p>通过<code>dispatch_get_main_queue</code>来获取主线程队列。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">dispatch_async(dispatch_get_main_queue())&#123;</span><br><span class="line">    [<span class="keyword">unowned</span> <span class="keyword">self</span>] <span class="number">_</span> <span class="keyword">in</span></span><br><span class="line">    <span class="keyword">let</span> myPhoneMain:<span class="type">String</span> = <span class="string">"main queue iPhone"</span>;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"main queue is \(myPhoneMain)"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>将一个block提交到串行任务队列中</strong></p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> window:dispatch_queue_t = dispatch_queue_create(<span class="string">"com.wen.window"</span>, <span class="type">DISPATCH_QUEUE_SERIAL</span>)</span><br><span class="line">dispatch_async(window)&#123;</span><br><span class="line">    [<span class="keyword">unowned</span> <span class="keyword">self</span>] <span class="number">_</span> <span class="keyword">in</span></span><br><span class="line">    <span class="keyword">let</span> myWindow:<span class="type">String</span> = <span class="string">"window 7"</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"我的电脑操作系统：\(myWindow)"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>将一个block提交到并行任务队列中</strong></p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> phone:dispatch_queue_t = dispatch_queue_create(<span class="string">"com.wen.iphone"</span>, <span class="type">DISPATCH_QUEUE_CONCURRENT</span>)</span><br><span class="line">dispatch_async(phone)&#123;</span><br><span class="line">    [<span class="keyword">unowned</span> <span class="keyword">self</span>] <span class="number">_</span> <span class="keyword">in</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> myPhone:<span class="type">String</span> = <span class="string">"iPhone 6 Plus"</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"my Phone is \(myPhone)"</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">//切换到主线程</span></span><br><span class="line">    dispatch_async(dispatch_get_main_queue())&#123;</span><br><span class="line">        [<span class="keyword">unowned</span> <span class="keyword">self</span>] <span class="number">_</span> <span class="keyword">in</span></span><br><span class="line">        <span class="keyword">let</span> myPhoneMain:<span class="type">String</span> = <span class="string">"main queue iPhone"</span>;</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"main queue is \(myPhoneMain)"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>将一个block提交到延迟任务队列中</strong></p>
<p><code>dispatch_after</code>可以帮助我们延时提交<code>block</code>到任务队列，当我们创建<code>dispatch_time_t</code>变量时稍微注意一下即可：</p>
<ul>
<li>NSEC_PER_SEC 一秒有多少纳秒</li>
<li>USEC_PER_SEC 一秒有多少毫秒</li>
<li>NSEC_PER_USEC 一毫秒有多少纳秒</li>
</ul>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> exeTime:dispatch_time_t = dispatch_time(<span class="type">DISPATCH_TIME_NOW</span>, <span class="number">10</span>)</span><br><span class="line"><span class="keyword">let</span> mac:dispatch_queue_t = dispatch_queue_create(<span class="string">"com.wen.mac"</span>, <span class="type">DISPATCH_QUEUE_CONCURRENT</span>)</span><br><span class="line">dispatch_after(exeTime, mac)&#123;</span><br><span class="line">    [<span class="keyword">unowned</span> <span class="keyword">self</span>] <span class="number">_</span> <span class="keyword">in</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> myMac:<span class="type">String</span> = <span class="string">"MacBook Pro"</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"my mac is \(myMac)"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>将一个block提交到只执行一次的任务中</strong></p>
<p>这个非常适合做<code>单例</code>，唯一需要注意的地方是，<code>dispatch_once_t</code>最好是全局或者static变量，因为调试的时候不会出现稀奇古怪的问题。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">oneToken</span></span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">var</span> onePred:<span class="type">String</span>? = <span class="literal">nil</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">var</span> toKen:dispatch_once_t = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">dispatch_once(&amp;oneToken.toKen)&#123;</span><br><span class="line">    [<span class="keyword">unowned</span> <span class="keyword">self</span>] <span class="number">_</span> <span class="keyword">in</span></span><br><span class="line">    oneToken.onePred = <span class="string">"icepy"</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">print</span>(<span class="string">"once pred is \(oneToken.onePred)"</span>)</span><br></pre></td></tr></table></figure>
<p><strong>将block挂起或者恢复</strong></p>
<p>虽然此处可以挂起，但是并不能保证可以立即停止队列中正在运行的block，所以没法更精准的控制block。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> icepy:dispatch_queue_t = dispatch_queue_create(<span class="string">"com.wen.suspend"</span>, <span class="type">DISPATCH_QUEUE_SERIAL</span>)</span><br><span class="line">dispatch_async(icepy)&#123;</span><br><span class="line">    <span class="type">NSThread</span>.sleepForTimeInterval(<span class="number">8</span>)</span><br><span class="line">    <span class="keyword">let</span> callback:<span class="type">String</span> = <span class="string">"Swift ---"</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"延迟执行第一个提交:\(callback)"</span>)</span><br><span class="line">&#125;</span><br><span class="line">dispatch_async(icepy)&#123;</span><br><span class="line">    <span class="type">NSThread</span>.sleepForTimeInterval(<span class="number">8</span>)</span><br><span class="line">    <span class="keyword">let</span> callback:<span class="type">String</span> = <span class="string">"Objective-C ---"</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"延迟执行第二个提交:\(callback)"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">"延迟1秒"</span>)</span><br><span class="line"><span class="type">NSThread</span>.sleepForTimeInterval(<span class="number">1</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">"--- 挂起"</span>)</span><br><span class="line">dispatch_suspend(icepy)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">"延迟10秒"</span>)</span><br><span class="line"><span class="type">NSThread</span>.sleepForTimeInterval(<span class="number">8</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">"--- 恢复"</span>)</span><br><span class="line">dispatch_resume(icepy)</span><br></pre></td></tr></table></figure>
<p><strong>向一个队列添加多个block</strong></p>
<p><code>dispatch_apply</code>有一个毛病，就是会阻塞外部线程，所以如果要使用还需要注意。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> more:dispatch_queue_t = dispatch_queue_create(<span class="string">"com.wen.more"</span>, <span class="type">DISPATCH_QUEUE_SERIAL</span>)</span><br><span class="line">dispatch_apply(<span class="number">3</span>, more)&#123;</span><br><span class="line">    [<span class="keyword">unowned</span> <span class="keyword">self</span>] (i:<span class="type">Int</span>) -&gt; <span class="type">Void</span> <span class="keyword">in</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"apply loop \(i)"</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">print</span>(<span class="string">"after apply"</span>)</span><br></pre></td></tr></table></figure>
<p><strong>dispatch_group</strong></p>
<p>创建一个<code>dispatch_group</code>分为三步：</p>
<ul>
<li>创建<code>dispatch_group_t</code></li>
<li>创建<code>dispatch_queue_t</code>并使用<code>dispatch_group_async</code>将<code>dispatch_queue_t</code>添加到group中</li>
<li>添加结束任务，比如<code>dispatch_group_notify</code></li>
</ul>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> group:dispatch_group_t = dispatch_group_create()</span><br><span class="line"><span class="keyword">let</span> thread1:dispatch_queue_t = dispatch_queue_create(<span class="string">"com.wen.thread1"</span>, <span class="type">DISPATCH_QUEUE_CONCURRENT</span>)</span><br><span class="line"><span class="keyword">let</span> thread2:dispatch_queue_t = dispatch_queue_create(<span class="string">"com.wen.thread2"</span>, <span class="type">DISPATCH_QUEUE_CONCURRENT</span>)</span><br><span class="line"><span class="keyword">let</span> notify:dispatch_queue_t = dispatch_queue_create(<span class="string">"com.wen.notify"</span>, <span class="type">DISPATCH_QUEUE_SERIAL</span>)</span><br><span class="line">dispatch_group_async(group, thread1)&#123;</span><br><span class="line">    <span class="number">_</span> <span class="keyword">in</span></span><br><span class="line">    <span class="keyword">let</span> myBook:<span class="type">String</span> = <span class="string">"JavaScript"</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"my book is \(myBook)"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">dispatch_group_async(group, thread2)&#123;</span><br><span class="line">    <span class="number">_</span> <span class="keyword">in</span></span><br><span class="line">    <span class="keyword">let</span> myBook:<span class="type">String</span> = <span class="string">"Swift"</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"my book is \(myBook)"</span>)</span><br><span class="line">&#125;</span><br><span class="line">dispatch_group_notify(group, notify)&#123;</span><br><span class="line">    <span class="number">_</span> <span class="keyword">in</span></span><br><span class="line">    <span class="keyword">let</span> myPro:<span class="type">String</span> = <span class="string">"web developer and iOS developer"</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"my pro is \(myPro)"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>避免死锁</strong></p>
<p>说到死锁，让我想起来一个<code>笑话</code>，心里嘿嘿笑一笑就好。如果使用同步的方法<code>dispatch_sync(&lt;#T##queue: dispatch_queue_t##dispatch_queue_t#&gt;, &lt;#T##block: dispatch_block_t##dispatch_block_t##() -&gt; Void#&gt;)</code>稍微不注意，就要恭喜你中奖了：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">send</span><span class="params">()</span></span>&#123;</span><br><span class="line">    dispatch_sync(dispatch_get_main_queue())&#123;</span><br><span class="line">        <span class="number">_</span> <span class="keyword">in</span></span><br><span class="line">        <span class="comment">//恭喜</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">dispatch_sync(dispatch_get_main_queue())&#123;</span><br><span class="line"></span><br><span class="line">    <span class="number">_</span> <span class="keyword">in</span></span><br><span class="line">    send()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

        
        </div>
        <footer class="article-footer">
            <div class="share-container">

    <div class="jiathis_style">
    <span class="jiathis_txt">分享到：</span>
    <a class="jiathis_button_qzone">QQ空间</a>
    <a class="jiathis_button_tsina">新浪微博</a>
    <a class="jiathis_button_tqq">腾讯微博</a>
    <a class="jiathis_button_weixin">微信</a>
    <a href="http://www.jiathis.com/share" class="jiathis jiathis_txt jiathis_separator jtico jtico_jiathis" target="_blank">更多</a>
    <a class="jiathis_counter_style"></a>
</div>
<script type="text/javascript" src="http://v3.jiathis.com/code/jia.js" charset="utf-8"></script>
<style>
    .jiathis_style div:first-child:not(.jiadiv_01) {
        width: auto !important;
        border: none !important;
    }
    .jiathis_style .jiadiv_01 {
        margin: 10px 0;
        border-radius: 4px;
        border: #e1e1e1 solid 1px;
    }
    .jiathis_style .jiadiv_01 div:first-child {
        display: none;
    }
    .jiathis_style .jiadiv_02 {
        padding: 7px 0 !important;
    }
    .jiathis_style .jiadiv_02 .jiatitle {
        width: 85px;
        border: none;
        height: auto;
        margin: 3px 10px;
        padding: 6px 10px;
        border-radius: 4px;
    }
    .jiathis_style .jiadiv_02 .jiatitle:hover {
        border: none;
    }
    .jiathis_style .jiadiv_02 .jiatitle:nth-child(even) {
        margin-left: 0;
    }
    .jiathis_style .jtico:hover {
        opacity: 1;
    }
    .jiathis_style .ckepopBottom,
    .jiathis_style .centerBottom {
        width: auto !important;
        padding: 5px;
        background: #f7f7f7;
    }
</style>



</div>

            
    
        <a href="https://mulgore.github.io/2015/12/21/swift-gcd/#comments" class="article-comment-link ds-thread-count" data-thread-key="https://mulgore.github.io/2015/12/21/swift-gcd/">评论</a>
    

        </footer>
    </div>
    
</article>



    <article id="post-javascript-learn" class="article article-type-post" itemscope itemprop="blogPost">
    <div class="article-inner">
        
        
        
            <header class="article-header">
                
    
        <h1 itemprop="name">
            <a class="article-title" href="/2015/12/16/javascript-learn/">前端开发基础－JavaScript</a>
        </h1>
    

                <div class="article-meta">
                    
    <div class="article-date">
        <i class="fa fa-calendar"></i>
        <a href="/2015/12/16/javascript-learn/">
            <time datetime="2015-12-16T04:11:15.000Z" itemprop="datePublished">2015-12-16</time>
        </a>
    </div>


                    
                    
    <div class="article-tag">
        <i class="fa fa-tag"></i>
        <a class="tag-link" href="/tags/JavaScript/">JavaScript</a>
    </div>

                </div>
            </header>
        
        <div class="article-entry" itemprop="articleBody">
        
            
            <p>这是很久很久之前想写的东西，拖了五六个月，没有动笔，现今补齐，内容有些多，对初学者有用，错误之处，望指出。</p>
<h2 id="理解作用域"><a href="#理解作用域" class="headerlink" title="理解作用域"></a>理解作用域</h2><p>理解作用域链是Js编程中一个<strong>必须</strong>要具备的，作用域决定了变量和函数有权力访问哪些数据。在Web浏览器中，全局执行环境是window对象，这也意味着所有的全局变量或者方法都是window对象的属性或方法。当一个函数在被调用的时候都会创建自己的执行环境，而这个函数中所写的代码就开始进入这个函数的执行环境，于是由变量对象构建起了一个作用域链。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> wow = <span class="string">'魔兽世界'</span>;</span><br><span class="line"><span class="keyword">var</span> message = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">	<span class="keyword">var</span> _wow = <span class="string">'123'</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在这个例子中全局环境中包含了两个对象（全局环境的变量对象不算），window.wow和window.message，而这个message函数中又包含了两个对象，它自己的变量对象（其中定义了arguments对象）和全局环境的变量对象。当这个函数开始执行时，message自己的变量对象中定义了_wow，而它的全局环境的变量对象有wow，假设在message中alert一下wow，实际上是message中包含的全局环境的变量对象.wow，于是可以访问。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> wow = <span class="string">'123'</span>;</span><br><span class="line"><span class="keyword">var</span> message = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">	<span class="keyword">var</span> wow = <span class="string">'456'</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果执行message函数alert一下wow，它的作用域是这样开始搜索的，先搜索message自己的变量对象中是否存在wow，如果有就访问并且立马停止搜索，如果没有则继续往上访问它，有wow，则访问并且立马停止搜索，以此类推一直搜索到全局环境上的变量对象，如果这里都没，恭喜你，这里要抛错了。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> c = <span class="string">'123'</span>;</span><br><span class="line"><span class="keyword">var</span> message = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">	<span class="keyword">var</span> g = <span class="string">'123'</span>;</span><br><span class="line">	<span class="keyword">var</span> a = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">		<span class="keyword">var</span> d = <span class="string">'123'</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在这个例子中包含有三个执行环境，全局环境，message的环境，a的环境。从这里可以看出message自身包含两个对象，自己的变量对象和全局环境中的变量对象，而函数a则包含了三个，自身的变量对象，message的变量对象和全局变量对象。</p>
<p>当开始执行这个函数时，在函数a中可以访问到变量g，那是因为函数a包含了message的变量对象，于是在自身没有开始搜索上一级的变量对象时发现了，于是可以访问。那么访问c的原理也是如此，当自身和上一级的message的变量对象都没有，但是全局变量对象中存在，于是访问成功。</p>
<p>了解这个作用域，对于Js编程是至关重要的，不然可能会出现，明明想要的预期结果是123，但是变成了456，为什么？那就是因为一级一级的搜索，可能会存在覆盖，或者搜索到别的地方就立即停止搜索了。</p>
<h2 id="理解引用类型"><a href="#理解引用类型" class="headerlink" title="理解引用类型"></a>理解引用类型</h2><p>引用类型虽然看起来和类很相似，但是它们却是不同的概念，引用类型的值，也就是对象是引用类型的一个实例。在Js中引用类型主要有Object，Array，Date，正则，Function等。</p>
<p>Object和Function在后面详细复述。</p>
<p><strong>Array</strong></p>
<p>在Js中数组可以存储任意的数据，而且它的大小是可以动态调整的类似于OC中的NSMutableArray。创建数组可以使用构造函数的方式也可以使用字面量的形式，另外可以使用concat从一个数组中复制一个副本出来。数组本身提供了很多方法让开发者使用来操作数组。</p>
<ul>
<li>length 数组的长度</li>
<li>toString  可以返回一个以，拼接的字符串，相当于是调用了下join(‘,’)</li>
<li>join 可以用一个分割符来拼接成一个字符串</li>
<li>push 添加一个数据到数组的末端</li>
<li>pop 删除数组中的最后一项，有返回值</li>
<li>shift 删除数组的第一项，有返回值</li>
<li>unshift 添加一个数据到数组的首端</li>
<li>reverse 倒序</li>
<li>sort 可以传入一个排序的函数</li>
<li>slice 可以基于当前数组返回一个新的数组，接收两个参数，返回项的起始位置和结束位置</li>
<li>splice 可以传入N个参数，第一个参数表示要删除，插入或则替换的位置，第二个参数表示要删除的项数，第三个到第N个表示要插入或则替换的数据</li>
</ul>
<p><strong>Date</strong></p>
<p>时间对象也是使用非常多的玩意，它是使用GMT时间来描述，而且时间对象是可以直接比对大小的。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> date1 = <span class="keyword">new</span> <span class="built_in">Date</span>(<span class="number">2015</span>,<span class="number">1</span>,<span class="number">2</span>);</span><br><span class="line"><span class="keyword">var</span> date2 = <span class="keyword">new</span> <span class="built_in">Date</span>(<span class="number">2015</span>,<span class="number">1</span>,<span class="number">10</span>);</span><br><span class="line">date1 &lt; date2</span><br></pre></td></tr></table></figure>
<p>常用的方法</p>
<ul>
<li>getTime 获取时间对象的毫秒数</li>
<li>setTime 设置时间对象的毫秒数，会改变日期</li>
<li>getFullYear 获取时间对象的年（2015）</li>
<li>getMonth 获取时间对象的月（需要加1）</li>
<li>getDay 获取日期的星期几（0-6）星期天到星期六</li>
<li>getDate 获取日期的天数</li>
<li>getHours 获取当前日期的小时</li>
<li>getMinutes 获取当前日期的分钟数</li>
<li>getSeconds 获取当然日期的秒数</li>
</ul>
<p>上面看起来都是获取，当然也有设置，只是相应的get置换成set即可。</p>
<p><strong>正则表达式</strong></p>
<p>在Js里正则表达式是用RegExp类型来支持的，关于正则可以看看之前写的一篇文章，用python来描述的如何读懂正则。</p>
<p>Js也支持三种模式，gim，表示全局，不区分大小写，多行。</p>
<p>一般来说很少有人这么使用var xxx = new RegExp()，而是用字面量的方式，比如var xx = /[bc]/gi;像用的比较多的方法有exec用于捕获包含第一个匹配项的数组，没有则返回null。test，用于判断，如果匹配返回true，不匹配返回false。</p>
<p><strong>处理字符串</strong></p>
<p>在Js中还有一种叫做包装类型的玩意，正因为此所以处理一些基本数据类型，比如字符串时，有很多方法可以使用。</p>
<ul>
<li>concat 可以将一个或者多个字符串拼接起来，返回一个新的字符串</li>
<li>slice 接收两个参数，起始位置和结束位置，返回一个新的字符串</li>
<li>substr和substring和slice一样，唯一的不同是substr第二个参数是返回字符串的个数</li>
<li>indexOf 从头开始查询字符串，存在会返回它所在的位置，没有返回－1</li>
<li>lastIndexOf 从最后开始查询字符串</li>
<li>toUpperCase 转大写</li>
<li>toLowerCase 转小写</li>
<li>match 正则表达式使用跟exec一样</li>
<li>search 正则表达式使用，查询到返回一个位置，没有返回－1</li>
<li>replace 替换，第一个参数可以是正则表达式也可以是字符串，第二个参数是要替换的字符串</li>
<li>localeCompare比较字符串，如果字符串相等返回0，如果字符串的字母排在参数字符串之前，返回负数，如果是之后，返回正数。</li>
</ul>
<h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><ul>
<li><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Functions" target="_blank" rel="external">Function</a></li>
</ul>
<p>说起来Js的核心是什么？那就是函数了。对于函数主要是理解它的几个概念。</p>
<ul>
<li>它可以当值来传递，没有重栽。</li>
<li>声明的时候，比如function a(){} var a = function(){} 执行时会有区别</li>
<li>函数内部的参数arguments包含了传入的所有参数</li>
<li>this，表示在这个函数内的作用域，以及prototype</li>
</ul>
<h2 id="理解匿名函数和闭包"><a href="#理解匿名函数和闭包" class="headerlink" title="理解匿名函数和闭包"></a>理解匿名函数和闭包</h2><p>匿名函数又叫拉姆达函数，主要是在把函数当值传递的时候用，或者是把函数当返回值，比如：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">d</span>(<span class="params">callback</span>)</span>&#123;</span><br><span class="line">	callback();</span><br><span class="line">&#125;</span><br><span class="line">d(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">	alert(<span class="string">'123'</span>)</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">//或者</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">b</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">		alert(<span class="string">'123'</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> g = b();</span><br><span class="line">g();</span><br></pre></td></tr></table></figure>
<p>其实第二种方式跟闭包的意义一样了，所谓的闭包书面的解释是可以访问另一个函数作用域内变量的函数，稍微改写一下可能会更明显。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">b</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">	<span class="keyword">var</span> name = <span class="string">'123'</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">		alert(name);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> g = b();</span><br><span class="line">g();</span><br></pre></td></tr></table></figure>
<p>从这里可以看出来return的函数可以访问到name，而外部却不行，这个返回值的函数就可以理解为闭包。理解闭包还可以看一个经典的求值的例子。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">save_i</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">	<span class="keyword">var</span> a = [];</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>;i&lt;<span class="number">10</span>;i++)&#123;</span><br><span class="line">		a[i] = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">			<span class="keyword">return</span> i;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> c = save_i();</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>;i&lt;<span class="number">10</span>;i++)&#123;</span><br><span class="line">	alert(c[i]());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从这个例子上来看，我们想得到的结果是10次循环a[i]保存着一个闭包，然后alert出从0到10，但是结果很出人意料，全部是10，为什么？哪里理解的不对呢？a[i]明明是内部函数，然后让它访问另外一个函数作用域内的变量i。</p>
<p>个人觉得可以这样去分析问题，在客户端执行Js时有一个全局执行环境，指向的是window对象。而所谓的对象也就是引用类型，实际上在后台执行环境中，它就是一个指针。</p>
<p>回到Js当代码在执行的时候，会创建变量对象并且构建一个作用域链，而这个对象保存着当前函数可以访问的对象。</p>
<pre><code>window
    -&gt;save_i
        -&gt;this|argument
        -&gt;a
        -&gt;i
        -&gt;看不见的a[0]-a[10]
        -&gt;a[0]function(){}
            -&gt;i
    -&gt;c
</code></pre><p>上述的i和a[0]里的i是同一个i，那么结果就是10。</p>
<p>进一步处理</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">save_i</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">	<span class="keyword">var</span> a = [];</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>;i&lt;<span class="number">10</span>;i++)&#123;</span><br><span class="line">		a[i] = <span class="function"><span class="keyword">function</span>(<span class="params">k</span>)</span>&#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">				<span class="keyword">return</span> k;</span><br><span class="line">			&#125;;</span><br><span class="line">		&#125;(i)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> c = save_i();</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>;i&lt;<span class="number">10</span>;i++)&#123;</span><br><span class="line">	<span class="built_in">console</span>.log(c[i]());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>接着按上面的节奏来分析</p>
<pre><code>window
    -&gt;save_i
        -&gt;this|argument
        -&gt;a
        -&gt;i
        -&gt;看不见的a[0]-a[10]
        -&gt;a[0]function(){}
            -&gt;k
            -&gt;function(){}
                -&gt;k

    -&gt;c
</code></pre><p>什么是传参？按值传递，相当于是在那个立即执行的函数中创建了一个新的地址和空间，虽然值是一样的，但是每一个k又是不同的，所以得到的结果正好满足了我们的预期。</p>
<p>本来正常情况下save_i执行完毕后就要销毁，但是内部的闭包被包含在这个作用域内了，所以save_i没法销毁，从这里可以看的出来闭包会带来内存的问题，因为用完之后没法销毁，如果不注意的话。</p>
<p>那么用完之后只能设置为null来解除引用，等着自动销毁把内存回收。</p>
<h2 id="Object"><a href="#Object" class="headerlink" title="Object"></a>Object</h2><p>JavaScript的所有对象都衍生于Object对象，所有对象都继承了Object.prototype上的方法和属性，虽然它们可能会被覆盖，熟悉它对于编程能起到很大的作用，也能比较深刻的了解JavaScript这门语言。</p>
<p><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object" target="_blank" rel="external">Object</a></p>
<p>创建一个对象可以使用new，也可以使用快速创建的方式：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> _object = &#123;&#125;;</span><br></pre></td></tr></table></figure>
<p>_object对象中就可以使用Object.prototype中所有的方法和属性，虽然看起来它是空的。说到这里在编程中常常有一个非常有用的需求，如何判断一个对象是空对象。</p>
<p>这是zepto中的判断一个对象是否是空对象，常常使用：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$.isEmptyObject = <span class="function"><span class="keyword">function</span>(<span class="params">obj</span>) </span>&#123;</span><br><span class="line">    	<span class="keyword">var</span> name</span><br><span class="line">    	<span class="keyword">for</span> (name <span class="keyword">in</span> obj) <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    	<span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>也顺便看了下jQuery原理是一模一样的：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">isEmptyObject: <span class="function"><span class="keyword">function</span>(<span class="params"> obj </span>) </span>&#123;</span><br><span class="line">	<span class="keyword">var</span> name;</span><br><span class="line">	<span class="keyword">for</span> ( name <span class="keyword">in</span> obj ) &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用in操作符来实现，它不会遍历到父原型链。</p>
<p>constructor返回一个指向创建了该对象的函数引用，这个东西主要是可以用来识别（类）到底是指向哪里的。</p>
<p>defineProperty直接在一个对象上定义一个新属性，非常适合用于动态构建，传入三个参数［动态添加对象的目标对象，需要定义或被修改的属性名，需要定义的对象］，在第三个参数中可以有些属性来表示是否继承（<strong>proto</strong>），要不要定义get，set方法，enumerable是否可枚举。</p>
<p>defineProperties跟上述defineProperty一样，但是它可以添加多个。</p>
<p>getOwnPropertyNames返回一个由指定对象的所有属性组成的数组</p>
<p>keys返回一个数组包括对象所有的属性（可枚举）</p>
<blockquote>
<p>keys是经常会用到的一个属性，它只能包可枚举的，如果想获取一个对象的所有属性包括不枚举的，那么使用getOwnPropertyNames。</p>
</blockquote>
<p>hasOwnProperty用于判断某个对象是否包含有自身的属性，这个方法常常用于检测对象中的属性是否存在，它只检测自身，对于继承过来的都是false，这一点是非常重要的理解。</p>
<p>isPrototypeOf 用于检测一个对象是否在另一个对象的原型链上，比如有两个对象是互相交互的，常常会使用它来进行检测。</p>
<p>propertyIsEnumerable这个方法也比较重要，返回一个布尔值，检测一个对象的自身属性是否可以枚举</p>
<blockquote>
<p>可枚举的理解，也就是对象的属性可枚举，它的属性值不可以修改，但是在Js中它有自己的定义，引擎内部看不见的该属性的[[Enumerable]]特性为true，那么就是可枚举的。基本上把一个普通对象可以看做是一个枚举类型，比如var color = {‘red’:1}，red是可以修改的，但是red是可枚举的，但是如果是继承过来的属性，propertyIsEnumerable是返回false的，它还有一个特点，就是自身。</p>
</blockquote>
<p>如果要定义不可枚举的属性，那就要使用defineProperty方法了，目前不能用对象直接量或者构造函数定义出来。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;name: <span class="string">'jack'</span>, age:<span class="number">23</span>&#125;</span><br><span class="line"><span class="built_in">Object</span>.defineProperty(obj, <span class="string">'id'</span>, &#123;value : <span class="string">'123'</span>, enumerable : <span class="literal">false</span> &#125;);</span><br></pre></td></tr></table></figure>
<h2 id="深拷贝与浅拷贝"><a href="#深拷贝与浅拷贝" class="headerlink" title="深拷贝与浅拷贝"></a>深拷贝与浅拷贝</h2><p>关于拷贝的问题，主要分为深拷贝和浅拷贝，但是如果从空间分配上来说JavaScript的拷贝不应该算是深拷贝，比如：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> d = &#123;&#125;;</span><br><span class="line"><span class="keyword">for</span>(k <span class="keyword">in</span> a)&#123;</span><br><span class="line">	d[k] = a[k];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> d;</span><br></pre></td></tr></table></figure>
<p>今天突然想到了这么一个问题，在C语言中，所谓的拷贝，就是分两种情况，一种是把指针地址拷贝给另外一个变量，虽然也开辟的了一个内存空间，在栈上也存在着一个地址，我对这个变量进行修改，同一个指针是会改变其值的，这种拷贝叫浅拷贝。另外一种情况，直接开辟一个新空间，把需要复制的值都复制在这个新的空间中，这种拷贝叫中深拷贝。</p>
<p>如果看到上述的一段Js代码，很多人说它是浅拷贝，假设传入一个a对象，拷贝完成之后返回一个d，当我修改返回对象的值时并不能同时修改a对象，于是，在这里我有一个很大的疑问，在Js中到底什么是浅拷贝，什么是深拷贝的问题？</p>
<p>这一点上感觉Js真的很奇葩，如果在开发iOS中，不可变对象copy一下，依然是不可变，所以是浅拷贝，拷贝了指针变量中存储的地址值。如果是可变对象copy一下，到不可变，空间变化了，包括不可变mutableCopy到不可变，空间依然变化了，所以是深拷贝。但是JavaScript中对于这一点要考虑一种情况，值类型，和引用类型，这个基础知识，我相信大家都非常清楚。数字，字符串等都是值类型，object，array等都是引用类型。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>];</span><br><span class="line"><span class="keyword">var</span> b = a;</span><br><span class="line"></span><br><span class="line">b.push(<span class="number">4</span>);</span><br><span class="line"><span class="built_in">console</span>.log(a); <span class="comment">//[1,2,3,4]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> numb = <span class="number">123</span>;</span><br><span class="line"><span class="keyword">var</span> _numb = numb;</span><br><span class="line">_numb = <span class="number">567</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(numb); <span class="comment">//123</span></span><br></pre></td></tr></table></figure>
<p>从这个例子中可以看的出来，它们使用的都是＝符号，而数组a发生了变化，numb数字却没有发生变化。那么从这里，可以有一个总结，所谓了深拷贝，浅拷贝的问题，应该针对的是有多个嵌套发生的情况。不然假设是这样的情况，还能叫浅拷贝么？</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> object = &#123;<span class="string">"de"</span>:<span class="number">123</span>&#125;;</span><br><span class="line"><span class="keyword">var</span> o = copy(object);</span><br><span class="line">o.de = <span class="number">456</span>;</span><br><span class="line"><span class="built_in">console</span>.log(object) <span class="comment">//&#123;"de":123&#125;</span></span><br></pre></td></tr></table></figure>
<p>明显对象o中的de属性修改并没有影响到原始对象，一个对象中的属性是一个字符串，如果从内存空间的角度上来说，这里明显是开辟了新的空间，还能说是浅拷贝么？那么针对另外一种情况。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> object = &#123;</span><br><span class="line">	<span class="string">"de"</span>:&#123;</span><br><span class="line">		<span class="string">"d"</span>:<span class="number">123</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> o = deepCopy(object);</span><br><span class="line">o.de.d = <span class="string">"asd"</span>;</span><br></pre></td></tr></table></figure>
<p>如果一个对象中的第一层属性，不是值类型，只单层循环，这样来看的话确实是一个浅拷贝，因为在Js中引用类型用＝赋值，实际上是引用，这样说的通。所以，深拷贝，还需要做一些处理，把object，array等引用类型识别出来，深层递归到最后一层，一个一个的拷贝。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> deepCopy = <span class="function"><span class="keyword">function</span>(<span class="params">o</span>)</span>&#123;</span><br><span class="line">	<span class="keyword">var</span> target = &#123;&#125;;</span><br><span class="line">	<span class="keyword">if</span>(<span class="keyword">typeof</span> o !== <span class="string">'object'</span> &amp;&amp; !<span class="built_in">Array</span>.isArray(o))&#123;</span><br><span class="line">		<span class="keyword">return</span> o;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">var</span> k <span class="keyword">in</span> o)&#123;</span><br><span class="line">		target[k] = deepCopy(o[k]);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> target;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>思路是如此，这个例子只考虑了两种情况，对象和数组，为了验证这样的思路，最后的结果与预期是一样的。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> _copy = &#123;</span><br><span class="line">	<span class="string">'object'</span>:&#123;</span><br><span class="line">		<span class="string">'name'</span>:<span class="string">'wen'</span></span><br><span class="line">	&#125;,</span><br><span class="line">	<span class="string">'array'</span>:[<span class="number">1</span>,<span class="number">2</span>]</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> h = deepCopy(_copy);</span><br><span class="line">h.object.name = <span class="string">'lcepy'</span>;</span><br><span class="line">h.array[<span class="number">1</span>] = <span class="number">8</span>;</span><br><span class="line"><span class="built_in">console</span>.log(h);</span><br><span class="line"><span class="built_in">console</span>.log(_copy);</span><br></pre></td></tr></table></figure>
<h2 id="面向对象"><a href="#面向对象" class="headerlink" title="面向对象"></a>面向对象</h2><p>面向对象的语言有一个非常明显的标志：类，通过类来创建任意多个具有相同属性和方法的对象，可惜的是Js里没有这样的概念。</p>
<p>但是Js有一个特性：一切皆是对象。</p>
<p>聪明的开发者通过这些特性进行摸索，于是迂回发明了一些程序设计，以便更好的组织代码结构。</p>
<h3 id="工厂模式"><a href="#工厂模式" class="headerlink" title="工厂模式"></a>工厂模式</h3><p>主要是用来解决有多个相同属性和方法的对象的问题，可以用函数来封装特定的接口来实现</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> computer = <span class="function"><span class="keyword">function</span>(<span class="params">name,version</span>)</span>&#123;</span><br><span class="line">	<span class="keyword">return</span> &#123;</span><br><span class="line">		<span class="string">'name'</span>:name,</span><br><span class="line">		<span class="string">'version'</span>:version,</span><br><span class="line">		<span class="string">'showMessage'</span>:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">			alert(<span class="keyword">this</span>.name);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> test = computer(<span class="string">'apple'</span>,<span class="string">'11.1'</span>);</span><br><span class="line">test.showMessage();</span><br></pre></td></tr></table></figure>
<h3 id="构造函数模式"><a href="#构造函数模式" class="headerlink" title="构造函数模式"></a>构造函数模式</h3><p>我们知道像原生的构造函数，比如Object，Array等，它们是在运行时自动出现在执行环境中的。因此，为了模仿它，这里也可以通过一个普通的函数，并且new出一个对象，这样就成为了自定义的构造函数，也可以为他们添加自定义的属性和方法。</p>
<p>但是这样的构造函数有一个缺陷，就是每个方法都会在每个实例上创建一次，因为每次创建都需要分配内存空间，但是有时候这样的特性还是有用的，主要是要控制它们，在不使用的时候释放内存。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> Computer = <span class="function"><span class="keyword">function</span>(<span class="params">name,version</span>)</span>&#123;</span><br><span class="line">	<span class="keyword">this</span>.name = name;</span><br><span class="line">	<span class="keyword">this</span>.version = version;</span><br><span class="line">	<span class="keyword">this</span>.showMessage = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">		alert(<span class="keyword">this</span>.name);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> apple = <span class="keyword">new</span> Computer(<span class="string">'apple'</span>,<span class="number">2014</span>);</span><br><span class="line"><span class="keyword">var</span> dell = <span class="keyword">new</span> Computer(<span class="string">'dell'</span>,<span class="number">2010</span>);</span><br><span class="line">apple.showMessage();</span><br><span class="line">dell.showMessage();</span><br></pre></td></tr></table></figure>
<p>像apple，dell是通过Computer实例化出来的不同的对象，但是它们的constructor都是指向Computer的。这里也可以使用instanceof来对（对象）进行检测。</p>
<p>在书写上构造函数跟其他函数是没有什么区别的，主要的区别还是在使用上，构造函数需要使用new操作符。</p>
<p>其实这样的书写，已经跟类没有什么区别了，表面上来看，而构造函数我个人更倾向于一个类的某个静态方法。</p>
<h3 id="原型模式"><a href="#原型模式" class="headerlink" title="原型模式"></a>原型模式</h3><p>说到原型模式就不得不提一提关于指针的问题，因为每一个函数都有一个prototype属性，而这个属性是一个指针，指向一个对象。</p>
<p><strong>C语言描述指针，这个在iOS开发中非常重要</strong></p>
<p>比如我先定义一个int类型的指针变量和一个普通的int类型数据，然后给指针变量赋值。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">int *p;</span><br><span class="line">int pp = 123;</span><br><span class="line">p = &amp;pp;</span><br><span class="line">*p = 999;</span><br><span class="line">printf('%d',pp);</span><br></pre></td></tr></table></figure>
<p>*是一个特殊符号用于标明它是一个指针变量。</p>
<p>&amp;是地址符</p>
<p>分析这个就要说到栈内存和堆内存了，比如*p在栈内存中分配了一个地址假设是ff22x0，它还没有空间。而pp存在一个地址ff23x0，并且分配了一个空间存储着123，这个地址是指向这个空间的。</p>
<p>p = &amp;pp 这样的赋值操作，也就是把ff23x0取出来，并且给p分配一个空间把ff23x0存储进去，并且ff22x0指向这个空间。</p>
<p>*p = 999 从这里就可以看出来p操作的是地址，而这个地址不就是ff23x0么，于是pp成了999。</p>
<p>所谓的指针也就是存储着地址的变量。</p>
<p>回到原型上，如果每一个函数中的 prototype属性都是一个指针，实际上它只是一个地址引用着一个空间，而这个空间正是我们写的xxx.prototype.xxx = function(){}这样的代码在运行时分配的空间。那么可见，使用原型的好处是空间只分配一次，大家都是共享的，因为它是指针。</p>
<p>先看一个例子</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> Computer = <span class="function"><span class="keyword">function</span>(<span class="params">name</span>)</span>&#123;</span><br><span class="line">	<span class="keyword">this</span>.name = name;</span><br><span class="line">&#125;</span><br><span class="line">Computer.prototype.showMessage = <span class="function"><span class="keyword">function</span>(<span class="params">name</span>)</span>&#123;</span><br><span class="line">	alert(name);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> apple = <span class="keyword">new</span> Computer(<span class="string">'apple'</span>);</span><br><span class="line"><span class="keyword">var</span> dell = <span class="keyword">new</span> Computer(<span class="string">'dell'</span>);</span><br><span class="line">Computer.prototype.isPrototypeOf(apple);</span><br></pre></td></tr></table></figure>
<p>在解释这个原型链之前，还要明白Js的一个特性，就是如果自身不存在，它会沿着原型往上查找。它的原理稍微有些绕，Computer自身的prototype是指向它自身的原型对象的，而每一个函数又有一个constructor指向它自身，prototype.constructor又指向它自身。于是Computer的两个实例apple，dell内部有一个<strong>proto</strong>属性是指向Computer.prototype的，最后的结果是它们可以使用showMessage方法。</p>
<p>当然它们还有一个搜索原则，比如在调用showMessage的时候，引擎先问apple自身有showMessage吗？“没有”，继续搜索，apple的原型有吗，“有”，调用。所以从这里可以看出，this.showMessage是会覆盖prototype.showMessage的。</p>
<p>另外还可以使用isPrototypeOf来检测一个对象是否在另一个对象的原型链上，上述的代码返回的是true。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">apple.hasOwnProperty(<span class="string">'name'</span>)</span><br><span class="line">apple.hasOwnProperty(<span class="string">'showMessage'</span>)</span><br></pre></td></tr></table></figure>
<p>使用hasOwnProperty来检测到底是对象属性还是原型属性，使用this创建的属性是一个对象属性。</p>
<p>从上面可以看出来原型链的好处，但是它也不是万能的，正因为指针的存在，对于某些引用类型来说这个就非常不好了，我需要保持原对象属性值是每一个对象特有的，而不是共享的，于是把之前的构造函数与原型组合起来，也就解决了这样的问题。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> Computer = <span class="function"><span class="keyword">function</span>(<span class="params">name</span>)</span>&#123;</span><br><span class="line">	<span class="keyword">this</span>.name = name;</span><br><span class="line">&#125;</span><br><span class="line">Computer.prototype.showMessage = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">	alert(<span class="keyword">this</span>.name);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> apple = <span class="keyword">new</span> Computer(<span class="string">'apple'</span>);</span><br><span class="line">apple.showMessage();</span><br></pre></td></tr></table></figure>
<p>这样的结果是在对象中都会创建一份属于自己的属性，而方法则是共享的。</p>
<p><strong>动态原型模式</strong></p>
<p>有时候遇到某些问题需要动态添加原型，但是实例中是不能添加的，所以绕来一下，在初始化构造函数中添加。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> Computer = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(<span class="keyword">typeof</span> <span class="keyword">this</span>.showMessage !== <span class="string">'function'</span>)&#123;</span><br><span class="line">		Computer.prototype.showMessage = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>只要初始化了一次，以后就不用修改了。</p>
<h3 id="寄生构造函数模式"><a href="#寄生构造函数模式" class="headerlink" title="寄生构造函数模式"></a>寄生构造函数模式</h3><p>这种模式的原理就是在一个函数中封装需要创建对象的代码，然后返回它。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> test = <span class="function"><span class="keyword">function</span>(<span class="params">name</span>)</span>&#123;</span><br><span class="line">	<span class="keyword">return</span> &#123;</span><br><span class="line">		<span class="string">'name'</span>:name</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> g = <span class="keyword">new</span> test(<span class="string">'apple'</span>);</span><br><span class="line"><span class="keyword">var</span> f = de(<span class="string">'dell'</span>);</span><br></pre></td></tr></table></figure>
<p>看起来它跟工厂模式还是很像的，</p>
<h3 id="稳妥模式"><a href="#稳妥模式" class="headerlink" title="稳妥模式"></a>稳妥模式</h3><p>这种模式主要是在解决需要安全的环境中使用，一般来说一个类如果不提供getter，setter方法，是不允许直接访问和修改的。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> computer = <span class="function"><span class="keyword">function</span>(<span class="params">name</span>)</span>&#123;</span><br><span class="line">	<span class="keyword">var</span> _name = name;</span><br><span class="line">	<span class="keyword">return</span> &#123;</span><br><span class="line">		<span class="string">'getter'</span>:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">			<span class="keyword">return</span> _name;</span><br><span class="line">		&#125;,</span><br><span class="line">		<span class="string">'setter'</span>:<span class="function"><span class="keyword">function</span>(<span class="params">name</span>)</span>&#123;</span><br><span class="line">			_name = name;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样的方式可以保证属性或者说是数据的安全性，不允许直接随便修改，如果不提供setter方法的话，压根就不允许。</p>
<h3 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h3><p>谈到面向对象，那么就不能不谈谈继承的问题了，而在Js中主要是将原型作为实现继承的主要思路。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> Computer = <span class="function"><span class="keyword">function</span>(<span class="params">name</span>)</span>&#123;</span><br><span class="line">	<span class="comment">//this.name = name;</span></span><br><span class="line">&#125;</span><br><span class="line">Computer.prototype.show = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">	alert(<span class="string">'computer'</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> Apple = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">Apple.prototype = <span class="keyword">new</span> Computer();</span><br><span class="line">Apple.prototype.hide = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;</span><br><span class="line">Apple.prototype.show = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">	alert(<span class="string">'apple'</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> apple = <span class="keyword">new</span> Apple();</span><br><span class="line">apple.show();</span><br><span class="line">alert(apple <span class="keyword">instanceof</span> Computer);</span><br></pre></td></tr></table></figure>
<p>使用这样的方式，实际上是从Computer的实例中先借它的prototype中所有的方法，但是这里会存在几个问题。</p>
<ul>
<li>如果Computer中需要传入参数，比如name，借的时候我根本不知道要传入什么参数。</li>
<li>在Apple中如果要继续给原型添加方法，那么就不能使用字面量的形式了，它会覆盖掉</li>
<li>如果要重写父类中的方法必须要在借prototype之后</li>
<li>那么如何确定原型和实例的关系？貌似用instanceof和isPrototypeOf都会返回true</li>
</ul>
<p><strong>解决问题一如何传入参数</strong></p>
<p>我们知道Js中有两个方法可以改变函数的上下文，apply和call，实际上类就是函数，这里既借属性也借prototype，不就可以解决这样的问题了么。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> Computer = <span class="function"><span class="keyword">function</span>(<span class="params">name</span>)</span>&#123;</span><br><span class="line">	<span class="comment">//this.name = name;</span></span><br><span class="line">&#125;</span><br><span class="line">Computer.prototype.show = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">	alert(<span class="string">'computer'</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> Apple = <span class="function"><span class="keyword">function</span>(<span class="params">name</span>)</span>&#123;</span><br><span class="line">	Computer.call(<span class="keyword">this</span>,name);</span><br><span class="line">&#125;</span><br><span class="line">Apple.prototype = <span class="keyword">new</span> Computer();</span><br><span class="line"><span class="keyword">var</span> apple = <span class="keyword">new</span> Apple(<span class="string">'apple'</span>);</span><br><span class="line">alert(apple <span class="keyword">instanceof</span> Apple);</span><br><span class="line">alert(apple <span class="keyword">instanceof</span> Computer);</span><br></pre></td></tr></table></figure>
<p>在运行时先借prototype，然后再借子类的this，但是这个也有个问题，那就是会调用两次父类。</p>
<p><strong>继承的技巧</strong></p>
<p>还有一种继承是生成一个临时对象，然后临时对象借需要继承的父类的prototype。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> extend = <span class="function"><span class="keyword">function</span>(<span class="params">o</span>)</span>&#123;</span><br><span class="line">	<span class="keyword">var</span> F = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;</span><br><span class="line">	F.prototype = o;</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">new</span> F();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> parent = &#123;</span><br><span class="line">	<span class="string">'name'</span>:[<span class="string">'lcepy'</span>]</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> game = extend(parent);</span><br><span class="line">game.name.push(<span class="string">'wow'</span>);</span><br><span class="line"><span class="keyword">var</span> _game = extend(parent);</span><br><span class="line">_game.name.push(<span class="string">'view'</span>);</span><br></pre></td></tr></table></figure>
<p>使用这样的方式有个很大的缺陷，那就是不要借属性之类的数据，因为它们是共享的，这是一个浅拷贝，还是因为指针的原因。不过要是继承方法，这种方式很方便。</p>
<p>还有一种方式跟上述类似，主要是封装了一层函数，用来返回对象。</p>
<h3 id="寄生组合继承"><a href="#寄生组合继承" class="headerlink" title="寄生组合继承"></a>寄生组合继承</h3><p>这样的方式主要解决的问题是调用两次父类的问题，避免额外的借来的属性或方法。想想看第一次Computer.call(this)，借来了this上的属性或方法，第二次Apple.prototype = new Computer()，又借来了this上的属性或方法，这里的初衷是想借原型，没办法这个是实例，所以该借的不该借的都借来了。那么要避免这样的问题，就要解决继承属性的继承属性，继承原型的继承原型，也不乱借。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> extendPrototype = <span class="function"><span class="keyword">function</span>(<span class="params">sub,supers</span>)</span>&#123;</span><br><span class="line">	<span class="keyword">var</span> F = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;</span><br><span class="line">	F.prototype = supers.prototype;</span><br><span class="line">	<span class="keyword">var</span> _f = <span class="keyword">new</span> F();</span><br><span class="line">	_f.constructor = sub;</span><br><span class="line">	sub.prototype = _f;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> Computer = <span class="function"><span class="keyword">function</span>(<span class="params">name</span>)</span>&#123;</span><br><span class="line">	<span class="keyword">this</span>.name = name;</span><br><span class="line">&#125;</span><br><span class="line">Computer.prototype.show = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">	alert(<span class="keyword">this</span>.name);</span><br><span class="line">&#125;		</span><br><span class="line"><span class="keyword">var</span> Apple = <span class="function"><span class="keyword">function</span>(<span class="params">name</span>)</span>&#123;</span><br><span class="line">	Computer.call(<span class="keyword">this</span>,name);</span><br><span class="line">&#125;</span><br><span class="line">extendPrototype(Apple,Computer);			</span><br><span class="line"><span class="keyword">var</span> apple = <span class="keyword">new</span> Apple(<span class="string">'apple'</span>);</span><br><span class="line">apple.show();</span><br></pre></td></tr></table></figure>
<p>第一步把supers的原型赋值给F，第二步创建F的实例，第三步把_f实例的constructor属性修改成子类，第四步把_f实例赋值给子类的prototype。</p>
<p>这样的话就是不该借的也不会继承了</p>
<h2 id="理解内存管理"><a href="#理解内存管理" class="headerlink" title="理解内存管理"></a>理解内存管理</h2><p>一般来说内存管理主要有这么几种方式，引用计数和标记，而JavaScript采用的就是标记管理的方式。Js的内存管理是自动的，但是并不是说执行完后立马销毁，而是有时间周期性，相隔一段时间执行一下垃圾回收，把没有引用的内存全部销毁。</p>
<p>OC中采用的是引用计数来手动管理内存，这样的方式比较好，可以让开发者自己来管理。当然也有不好的地方，如果遗忘了释放，很可能引起应用的崩溃。</p>
<p>总体来看在IE中因为COM组件的原因，可能会发生循环引用的问题，这个问题在引用计数的内存管理都会遇见。所谓的循环引用是指在对象A中包含了一个指向B的指针，然后再对象B中包含一个指向A的指针，于是悲剧了。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> element = <span class="built_in">document</span>.getElementById(<span class="string">'doc'</span>);</span><br><span class="line"><span class="keyword">var</span> my = &#123;&#125;;</span><br><span class="line">my.element = element;</span><br><span class="line">element.my = my;</span><br></pre></td></tr></table></figure>
<p>大家都引用，于是，可想而知。要避免这种问题，一定要在不使用的时候my.element = null，把它断开。</p>
<p>那么，其他浏览器呢？还是标记清理的机制，比如一个函数的变量，在进入环境时标记上“进入环境”，执行完之后标记上“离开环境”，然后等待系统来释放。</p>
<p>IE有一个手动释放的方法，window.CollectGarbage，调用它就立马释放已经标记离开环境的变量，不过很多文章都不建议这样做。</p>
<p>那么一般都这样做，引用类型的释放</p>
<pre><code>var my = {};
//使用完毕之后
my = null;
</code></pre><p>让my脱离执行环境，标记上已经离开环境，然后等待系统执行垃圾回收，释放内存。</p>
<h2 id="XMLHttpRequest"><a href="#XMLHttpRequest" class="headerlink" title="XMLHttpRequest"></a>XMLHttpRequest</h2><ul>
<li><a href="https://developer.mozilla.org/zh-CN/docs/Web/Security/Same-origin_policy" target="_blank" rel="external"> JavaScript 的同源策略</a></li>
</ul>
<blockquote>
<p>注明： IE8已上，支持现代XMLHttpRequest</p>
</blockquote>
<p>客户端Js与服务器进行网络交互必备的一个玩意，它不支持跨域，若要跨域还需要进行一些额外的处理。</p>
<pre><code>var xhr = new XMLHttpRequest();
</code></pre><p>在使用xhr对象时，要调用的第一个方法是open()，它接受三个参数［发送请求的类型，请求的URL，描述是否同步还是异步的布尔值］false同步，true异步。</p>
<p>关于Ajax同步异步的个人理解：</p>
<ul>
<li>同步，是用数据块的方式来传输的，在Js执行的表现上，当执行到这个Ajax请求时会等待它与服务器交互成功之后才能执行下面一行的代码，也就是阻塞。</li>
<li>异步，是用字节来传输的，它不等待是否成功，会执行之后的代码</li>
</ul>
<p>结束时需要调用xhr.send()，如果没有发送数据的主体，必须要null，做为发送参数。另外在接收到响应之前还可以调用abort()来取消异步请求（不建议调用它）</p>
<h3 id="HTTP状态验证"><a href="#HTTP状态验证" class="headerlink" title="HTTP状态验证"></a>HTTP状态验证</h3><p>当收到响应后会自动填充xhr对象，它有几个比较重要的状态，我们必须要了解清楚与处理。</p>
<ul>
<li>responseText:作为响应主体返回的文本</li>
<li>responseXML:如果响应内容的类型是”text/xml”或者”application/xml”，这个属性中保存的就是XML的DOM文档</li>
<li>status：响应的HTTP状态</li>
<li>statusText：HTTP状态的说明</li>
<li>readyState：用于描述请求发送到完成的过程</li>
</ul>
<p>正常情况下需要检测status === 200 readyState === 4 这就表示responseText或者responseXML中已经填充了全部的数据可以提供给客户端使用了。</p>
<pre><code>1 开头的用于描述请求已经发送，需要请求者继续操作才能继续的状态
2 开头的用于描述请求已经成功
3 开头的用于描述成功，但是还需要继续操作
4 开头的用于描述客户端发送了什么数据导致服务器错误
5 开头的用于描述服务器错误（常见的如，服务端代码抛错了）
</code></pre><p>readyState状态</p>
<pre><code>0 未初始化，还没有调用open方法
1 已经调用open方法，还没有调用send方法
2 已经调用send方法，但是还没有接收到响应
3 已经接收了部分数据
4 已经接收了全部的数据
</code></pre><h3 id="xhr对象其他方法或事件"><a href="#xhr对象其他方法或事件" class="headerlink" title="xhr对象其他方法或事件"></a>xhr对象其他方法或事件</h3><p>每一个请求和响应都会带有相应的HTTP头信息，其中对开发者是很有用的，而xhr对象提供了一个setRequestHeader方法来设置头信息，它必须在调用open方法之后并且在send方法之前。</p>
<p>既然有设置，那么必须得有获取，xhr对象也提供了两个方法分别来获取，getResponseHeader传入一个头部字段名来获取，getAllResponseHeaders来获取全部的头信息。</p>
<p>而接收数据则需要处理onreadystatechange事件，每次刷新状态时，系统都会重新调用此事件。</p>
<h2 id="跨域"><a href="#跨域" class="headerlink" title="跨域"></a>跨域</h2><ul>
<li><a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Access_control_CORS" target="_blank" rel="external">HTTP访问控制(CORS)</a></li>
</ul>
<p>客户端Js出于安全的考虑，不允许跨域调用其他页面的对象，正是因为这样才给Ajax带来了很多不方便的地方。跨域最简单的理解就是因为Js同源策略的存在，比如a.com域名下的Js不能访问b.com下的Js对象。</p>
<ul>
<li>协议端口没法跨，客户端</li>
<li>在跨域上，域仅仅是通过首部来识别，window.location.protocol +window.location.host</li>
</ul>
<h3 id="利用document-domain和iframe来设置"><a href="#利用document-domain和iframe来设置" class="headerlink" title="利用document.domain和iframe来设置"></a>利用document.domain和iframe来设置</h3><p>对于主域相同而子域名不同的情况，可以通过document.domain来处理，比如www.163.com/index.html和wow.163.com/wower.html，在这两个文件中分别加入document.domain = “163.com”，然后在index.html页面中创建一个iframe引入wower.html，获取iframe的contentDocument，这样这两个js就可以交互了。</p>
<p>index.html</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">document</span>.domain = <span class="string">'163.com'</span>;</span><br><span class="line"><span class="keyword">var</span> iframe = <span class="built_in">document</span>.createElement(<span class="string">'iframe'</span>);</span><br><span class="line">iframe.src = <span class="string">'http://wow.163.com/wower.html'</span>;</span><br><span class="line">iframe.style.display = <span class="string">'none'</span>;</span><br><span class="line"><span class="built_in">document</span>.body.appendChild(iframe);</span><br><span class="line">iframe.onload = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">	<span class="keyword">var</span> doc = iframe.contentDocument || iframe.contentWindow.document;</span><br><span class="line">	<span class="comment">//现在可以通过doc来操作wower.html中的js对象了</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>wower.html</p>
<pre><code>document.domain = &apos;163.com&apos;;
</code></pre><p>使用这样的方式来实现的跨域是有限制的</p>
<ul>
<li>主域名必须是同一个</li>
<li>安全性引发的问题，比如第一个页面出现了安全问题，在后面的页面也会出现</li>
<li>iframe引用过多的话，每一个iframe都必须设置document.domain，比较琐碎</li>
</ul>
<blockquote>
<p>偶尔可以使用一下</p>
</blockquote>
<h3 id="利用window-name"><a href="#利用window-name" class="headerlink" title="利用window.name"></a>利用window.name</h3><p>稍微有些绕，但是数据量比较大，也比较安全</p>
<ul>
<li>wow.163.com/app.html 应用所在的页面</li>
<li>wow.163.com/empty.html 中间代理页面，搞个空的即可，但是必须在主域名下</li>
<li>www.qq.com/data.html 需要交互的数据页面</li>
</ul>
<p>在data.html页面中</p>
<pre><code>window.name = 123;
</code></pre><p>app.html页面中创建一个隐藏的iframe，它的scr指向data.html，在onload事件中，把当前iframe的contentWindow.loaction修改成empty.html，当再次onload时就可以通过contentWindow.name来获取到123了。</p>
<blockquote>
<p>偶尔使用</p>
</blockquote>
<h3 id="利用iframe和location-hash"><a href="#利用iframe和location-hash" class="headerlink" title="利用iframe和location.hash"></a>利用iframe和location.hash</h3><p>利用这种方式，说实话（不建议），比较绕，而且数据量小，直接暴露在URL上。它的原理主要是这样的，假设wow.163.com/index.html页面，wow.163.com/empty.html（空的，什么内容都没有），需要交换数据的页面在www.qq.com/a.html上。</p>
<p>在wow.163.com/index.html#（＃号就是我们要传递的数据），创建一个隐藏的iframe，hash值可以当参数传递给www.qq.com/a.html#()，在www.qq.com/a.html中可以获取到hash值，根据它进行处理，然后在www.qq.com/a.html页面中创建一个隐藏iframe，把处理的结果当hash值进行传递，给wow.163.com/empty.html#()这样，在同一个域名下，wow.163.com/empty.html中的js可以通过parent.parent.location.hash = self.location.hash来改变hash值，这样就达到了跨域的目的。</p>
<blockquote>
<p>不建议使用，坑爹的思路</p>
</blockquote>
<h3 id="JSONP"><a href="#JSONP" class="headerlink" title="JSONP"></a>JSONP</h3><p>这种方式是目前开发时最常用的一种方式，利用动态创建script标签来实现跨域的目的，虽然浏览器有显示Js对象的访问，但是它没有限制Js文件的加载，任何域名下的Js文件都可以加载。</p>
<p>对客户端而言，文件的加载其实就是发送一次GET请求，在服务端实现时，也就是处理这次的GET请求，并且响应，参数可以通过?来带走，俗称一波流。</p>
<p>在客户端上对于script文件加载是否已经完毕的判断，IE是判断script标签的readystatechange属性，而其他浏览器是onload事件。</p>
<blockquote>
<p>突然感觉做移动端不考虑IE的兼容，果然是杠杠的，建议使用</p>
</blockquote>
<h3 id="HTML5-postMessage"><a href="#HTML5-postMessage" class="headerlink" title="HTML5 postMessage"></a>HTML5 postMessage</h3><p>主要是利用window.postMessage来发送消息，监听window.message来获取消息，判断origin可以判断消息来源，data获取消息内容，soucre来引用发送方的window对象引用。</p>
<p>www.b.com/b.html发送消息给www.a.com/a.html</p>
<pre><code>window.postMessage(&apos;hello&apos;,&apos;www.a.com/a.html&apos;)
</code></pre><p>www.a.com/a.html获取消息</p>
<pre><code>window.addEventLister(&apos;message&apos;,function(event){
    if(event.origin === &apos;http://b.com&apos;){
        //处理
    }
})
</code></pre><p>iframe的发送方式</p>
<pre><code>contentWindow.postMessage(&apos;data&apos;,&apos;b.com&apos;)
</code></pre><blockquote>
<p>话不多说，移动端这种跨域方式也很常用（建议推荐使用）</p>
</blockquote>
<h3 id="HTML5-跨域头-XMLHttpRequest2"><a href="#HTML5-跨域头-XMLHttpRequest2" class="headerlink" title="HTML5 跨域头 XMLHttpRequest2"></a>HTML5 跨域头 XMLHttpRequest2</h3><p>如果是自己产品，又是做移动端可以使用，比上述任何方式都要方便，需要服务端支持响应时也要设置跨域头。</p>
<p>如果服务器响应此头，浏览器会检查此头，它的值表示请求内容所允许的域名，也就是如果是*号，表示所有域都可以访问，如果这里是a.com，表示除了同源外，只允许来自a.com域的访问。</p>
<pre><code>Access-Control-Allow-Origin：＊
</code></pre><p>如果需要读取cookie则需要设置它</p>
<pre><code>Access-Control-Allow-Credentials:true
</code></pre><p>设置允许跨域的请求类型</p>
<pre><code>Access-Control-Allow-Methods:POST
</code></pre><blockquote>
<p>兼容性问题，某些版本的浏览器需要在open之后，设置xhr.withCredentials ＝ true;话不多说，建议推荐使用</p>
</blockquote>
<h2 id="浏览器对象模型"><a href="#浏览器对象模型" class="headerlink" title="浏览器对象模型"></a>浏览器对象模型</h2><p>BOM提供了很多对象，它的核心是window，表示它是浏览器的一个实例，在ECMAScript中又是Global对象。它提供了很多访问浏览器的功能，这些功能与网页无关，所以缺少事实标准的BOM既有意思又有些坑。复习它，主要是复习几个比较有用的对象，其他可以了解一二。</p>
<h3 id="location"><a href="#location" class="headerlink" title="location"></a>location</h3><blockquote>
<p>算起来它是我用的最多的一个对象</p>
</blockquote>
<p>它提供了当前窗口加载的页面有关的信息，也对URL进行了片段分解，既是window的属性，也是document的属性。</p>
<ul>
<li>hash 返回URL的散列（#号后面跟着的零个或多个值）</li>
<li>host 返回服务器名称和端口号</li>
<li>hostname 返回不带端口号的服务器名称</li>
<li>href 返回当前加载页面的完整URL</li>
<li>pathname 返回URL中的目录或文件名</li>
<li>port 返回URL中指定的端口号</li>
<li>protocol 返回页面使用的协议</li>
<li>search 返回URL中的查询字符串，它以问好（?）开头</li>
</ul>
<p>上述的属性基本上都可以直接使用，search除外，它返回的是一个完整的查询字符串，没有办法访问其中的每个查询字符串参数，还需要额外的进行处理。</p>
<p>一般来说根据它的特点，?开头&amp;拼接，key=value的形式来展现，最好是key和value都要decodeURIComponent一下。</p>
<p>在location中除了上述的属性外，还有一些比较有用的方法和技巧，主要是用来控制页面跳转的问题。</p>
<ul>
<li>assign方法接收一个参数，表示立即打开一个新的页面并在历史纪录中生成一条记录，它的效果等同于window.location.href = ‘’或者location.href = ‘’</li>
<li>修改location对象的属性比如href，hash，search等也可以来改变URL</li>
<li>replace方法接收一个参数，既跳转到新的URL上，并且不会在历史纪录中增加一条新的纪录</li>
<li>reload表示重新加载当前页面</li>
</ul>
<h3 id="处理框架，设置时间，open，窗口位置，窗口大小"><a href="#处理框架，设置时间，open，窗口位置，窗口大小" class="headerlink" title="处理框架，设置时间，open，窗口位置，窗口大小"></a>处理框架，设置时间，open，窗口位置，窗口大小</h3><blockquote>
<p>open现在估计没人会用了</p>
</blockquote>
<p>如果页面中包含框架，则每个框架都有自己的window对象，可以使用frames来获取，比如frames[0]或者frames[‘name’]。这里还要了解的是top，parent，对于这些只要理解的层级关系，每一个指向都是会非常清楚的。</p>
<p>在做某些动画效果的时候，主要是针对PC端，可能会使用到窗口位置，窗口大小的属性来进行计算，比如innerWidth，innerHeight，outerWidth，outerHeight，获取到这些尺寸，一般会与当前div的高宽进行减法来获取精准的位置。</p>
<p>setTimeout和setInterval是进行时间调度的函数，我们知道Js是单线程的，但是可以使用这个在特定的时间范围内执行代码，前面一个setTimeout是在指定的时间内执行（只执行一次），后面的setInterval则是以指定的时间重复执行（N次）</p>
<h3 id="navigator"><a href="#navigator" class="headerlink" title="navigator"></a>navigator</h3><p>用这个一般是在统计用户浏览器版本，操作系统等场景下才用的上，偶尔有几个会比较实用。</p>
<ul>
<li>cookieEnabled 判断cookie是否开启</li>
<li>userAgent 浏览器用户代理字符串</li>
<li>plugins数组 主要是用来检测浏览器安装的插件</li>
</ul>
<p>###screen</p>
<p>在Js中有几个对象在编程里真用不上，这个就是其中之一。它主要是用来表明客户端的能力，比如显示器的信息，像素，高，宽等。</p>
<h3 id="history"><a href="#history" class="headerlink" title="history"></a>history</h3><p>history对象保存着用户上网的历史纪录，但是这个也是非常不常用。主要是用go方法，back方法，forward方法。</p>
<blockquote>
<p>说实话，后面三个navigator,screen,history基本上很废材，HTML5中的history对象pushState非常有用外。</p>
</blockquote>
<h2 id="文档对象模型"><a href="#文档对象模型" class="headerlink" title="文档对象模型"></a>文档对象模型</h2><ul>
<li><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Document_Object_Model" target="_blank" rel="external">文档对象模型 (DOM)</a></li>
</ul>
<p>DOM是针对HTML和XML文档的一个API，主要是使用JavaScript来进行编程操作HTML和XML文档。其他语言如果实现了DOM标准，理论上也是可以使用这个API的，这里仅仅讨论JavaScript的应用。</p>
<p><strong>理解层级结构与关系</strong></p>
<p>在浏览器中比如HTML页面是由很多有层次结构的标签组成的，而为这些标签提供查询，添加，删除等等方法主要就是DOM在提供支持。</p>
<p>（页面又称为文档）文档中所有的节点之间都存在这样或那样的关系，比如下面一个经典的HTML：</p>
<pre><code>&lt;html&gt;
    &lt;head&gt;&lt;/head&gt;
    &lt;body&gt;&lt;/body&gt;
&lt;/html&gt;
</code></pre><p>一个标签又可以称为一个元素，head和body那就是兄弟关系，它们都来自一个父系html，又可以说html的子元素是head和body，可能这样描述还不太明显，这样就用原生Js操作DOM来的方式来看看层级结构。</p>
<pre><code>var html = document.getElementsByTagName(&apos;html&apos;)[0];
</code></pre><p>先通过getElementsByTagName获取html根元素的节点，每一个元素都有一个childNodes集合和一个parentNode分别代表子节点集合和父节点，<strong>如果不存在，则都是null，如果是集合不存在，则是一个[]</strong>。</p>
<blockquote>
<p>html的childNodes //[head,body] html的parentNode // document</p>
</blockquote>
<p>每一个元素也都有一个firstChild和lastChild来分别代表第一个子元素和最后一个子元素</p>
<p>每一个元素也都有一个nextSibling和previousSibling分别代表前面一个元素和后面一个元素，以当前自己为参照物。</p>
<p>从这样可以看出来，它就像族谱一样对元素的关系进行了定义，通过理解这些层级关系，利用DOM提供的API可以很顺利的进行操作。</p>
<h3 id="操作DOM"><a href="#操作DOM" class="headerlink" title="操作DOM"></a>操作DOM</h3><p><strong>常见的获取方式</strong></p>
<ul>
<li>document.getElementById （通过ID来获取到节点）</li>
<li>document.getElementsByTagName （通过节点标签来获取）</li>
<li>document.querySelector  </li>
<li>document.querySelectorAll</li>
</ul>
<p>后面两个属于HTML5提供的新API，在移动端会用的比较多，前者是获取单个，后者获取集合。</p>
<p><strong>常见添加，删除</strong></p>
<ul>
<li>appendChild</li>
<li>insterBefore</li>
<li>replaceChild</li>
<li>removeChild</li>
</ul>
<p>appendChild主要是向childNodes集合的末尾添加一条元素，insterBefore可以用来插入特定位置，两个参数，要插入的节点和作为参照的节点，更新成功后插入的节点会在参照节点之前，也就是参照节点的previousSibling。replaceChild和insterBefore有些类似，两个参数，要插入的节点和参照节点，更新成功后，要插入的节点会替换参照节点，removeChild就比较好理解了，删除一个节点，这四个方法都有返回值。</p>
<p><strong>常见元素属性</strong></p>
<p>一般来说，如果var doc = document.getElementById(‘doc’);doc.id = ‘xx’;这样的方式也是可以更新或者获取到元素的属性的，不过不推荐这么使用，要获取元素的属性，DOM API也提供了三个方法来使用。</p>
<ul>
<li>getAttribute</li>
<li>setAttribute</li>
<li>removeAttribute</li>
</ul>
<p>getAttribute可以获取元素的属性，setAttribute可以对元素的属性进行设置，如果属性名不存在，则创建该属性。removeAttribute则是完全删除此属性。</p>
<p>还有一个属性attributes，主要是获取元素属性集合，这个不是很常用，主要是在遍历元素属性时会使用到，它是一个集合。</p>
<p><strong>常见创建元素或文本</strong></p>
<p>一般情况下创建元素都会使用字符串的形式，innerHTML进去。不过，某些情况下，会用到createElement来创建一个元素，如果用到它，那么创建的文本也必须使用createTextNode了。</p>
<p>对于文本节点，注释节点等开发真的很少用，可以当一个子类大概了解即可。</p>
<blockquote>
<p>关于模式的讨论，主要可以用document.compatMode来判断，如果是CSS1Compat就是标准模式，移动端不会出现这样的情况，IE上可能有别的模式，模式主要是影响到CSS布局上，Js影响非常少。</p>
<p>在移动端上滚动是一个比较要处理的问题，一般来说会使用scrollIntoView，scrollIntoViewIfNeeded，scrollByLines，scrollByPages，这四个方法safari chrome都有实现，意味着在iOS和安卓平台都是良好的。</p>
</blockquote>
<ul>
<li>scrollByPages 将元素的内容滚动到指定的页面高度，具体的高度是由元素的高度来决定的。</li>
<li>scrollByLines 将元素的内容滚动到知道的行数高度，参数可正可负。</li>
<li>scrollIntoViewIfNeeded，当元素在视窗（viewport）不可见，会滚动容器元素或者浏览器窗口让其可见。如果是可见的，这个方法不起任何作用。如果参数为true，可能是垂直居中的可见。</li>
<li>scrollIntoView 滚动容器元素或者浏览器窗口，让元素可见。</li>
</ul>
<p><strong>一些小技巧</strong></p>
<p>每一个元素都存在一个contains方法，用来检测传入的节点是不是当前节点的子节点，火狐对于的方法名叫compareDocumentPosition。</p>
<p>如果要获取一个文本节点可以使用innerText（纯文本）来获取字符串，如果要获取所有的包括标签的字符串可以使用innerHTML。它们还有一种outer系列对应的方法，主要的区别是前者（outerText）会替换节点，后者(outerHTML)会修改调用它的元素，一般基本没人使用。它们可以获取，也可以通过赋值来设置新的节点。</p>
<h3 id="DOM2和DOM3"><a href="#DOM2和DOM3" class="headerlink" title="DOM2和DOM3"></a>DOM2和DOM3</h3><p>对于这两级在DOM中基本上IE没啥支持，或者说支持的非常少，像style对象，CSS的一些对象外。</p>
<p>这里最大的变化是增加了对XML命名空间的支持，元素样式的访问，节点的遍历以及range。当然目前来看，节点的遍历，range，XML命名空间在开发中使用的非常少，可以当资料来阅读，了解有这么回事，用到的时候再查询。而元素样式的访问，这个在开发中普遍使用的较多，因为在没法使用css3动画的浏览器中，可以通过改变样式来到达动画的目的。</p>
<pre><code>var doc = document.getElementById(&apos;doc&apos;);
doc.style.width = &apos;100px&apos;;
</code></pre><p>对于iframe的访问这里增加了一个contentDocument对象来进行引用，还有节点的比较，isSameNode和isEqualNode，这两个的区别在于，前者是否引用的同一个节点对象，后者是指两个节点是否是相同的类型。不过，它们使用的也不多，了解就好。</p>
<p><strong>元素的大小</strong></p>
<p>这个部分需要理解，因为关乎到元素在浏览器上的位置显示，跟动画有关系，四个属性。</p>
<ul>
<li>offsetWidth 元素在水平方向占用的空间大小</li>
<li>offsetHeight 元素在垂直方向占用的空间大小</li>
<li>offsetLeft 元素的左外边框到内边框的距离</li>
<li>offsetTop 元素的上外边框到内边框的距离</li>
</ul>
<p><strong>滚动大小</strong></p>
<p>这个在视察滚动或者处理滚动条的时候用的上，也是四个属性</p>
<ul>
<li>scrollHeight 在没有滚动的情况下，元素的总高度</li>
<li>scrollWidth 在没有滚动的情况下，元素的总宽度</li>
<li>scrollLeft 被隐藏在内容区域左侧的像素度</li>
<li>scrollTop 被隐藏在内容区域上侧的像素度</li>
</ul>
<blockquote>
<p>下面这些IE全部不支持，range支持一种叫做文本范围的东西</p>
</blockquote>
<p><strong>元素遍历</strong></p>
<p>关于遍历其实有两个方法可用createNodeIterator和createTreeWalker，不过这些在开发中几乎不会使用到，谁没事去遍历节点完呢。</p>
<p><strong>关于range</strong></p>
<p>这个也是非常少会使用到，除非是做那种编辑器应用或者在线编辑器等等，不过使用它可以更精准的控制的DOM，主要是使用createRange方法。</p>
<h2 id="事件"><a href="#事件" class="headerlink" title="事件"></a>事件</h2><ul>
<li><a href="https://developer.mozilla.org/zh-CN/docs/Web/Events" target="_blank" rel="external">事件类型一览表</a></li>
</ul>
<blockquote>
<p>IE浏览器的事件不是重点</p>
</blockquote>
<p>事件是JavaScript与HTML进行交互的一个纽带，理解事件可以更好的处理Web应用程序，现在的浏览器中主要支持两种事件流：</p>
<ul>
<li>事件冒泡</li>
<li>事件捕获</li>
<li>DOM事件流</li>
</ul>
<p>事件冒泡则是指事件开始时由具体的元素接收，然后逐级向上传播。比如：</p>
<pre><code>&lt;html&gt;
    &lt;head&gt;&lt;/head&gt;
    &lt;body&gt;
        &lt;div&gt;
            &lt;p&gt;&lt;/p&gt;
        &lt;/div&gt;
    &lt;/body&gt;
&lt;/html&gt;
</code></pre><p>给p标签监听一个事件，它的流向是p,div,body,html,document，其实细心看来这种流的走向会存在一个问题，给div也监听一个事件，当用户点击P的时候是会触发两次的，好在event对象中有可以阻止事件冒泡的方法。</p>
<p>事件捕获则是指事件由最上级接收，逐级向下传播到具体的元素上，了解了冒泡之后这个就非常好理解了，正是一个相反的步骤。</p>
<p>而DOM事件流又正好是冒泡与捕获的结合体，它分为三个阶段：事件捕获，目标事件，事件冒泡，如果在纸上画出来，它的走向就是一个圆形。</p>
<blockquote>
<p>对于事件处理程序，写在HTML标签中的，另外一种是直接写一个function的，比如doc.onclick = function(){}，一般来说这些浏览器支持，但是基本上不会使用了。因为前者是跟HTML耦合的，不利代码维护，而且虽然HTML加载了但是Js文件还未加载，用户点击后，是直接报错的。后者虽然也可以删除，比如doc.onclick = null，对于对代码有强迫症的同学，基本上不会使用到它。</p>
</blockquote>
<p>那么，我们该怎么给一个元素添加上事件处理程序呢？</p>
<h3 id="DOM2级事件处理程序"><a href="#DOM2级事件处理程序" class="headerlink" title="DOM2级事件处理程序"></a>DOM2级事件处理程序</h3><ul>
<li>addEventLister</li>
<li>removeEventLister</li>
</ul>
<p>所有的DOM节点都具备这两个方法，它接收三个参数：</p>
<ul>
<li>要处理的事件名称，比如click（这里跟上述两个以及IE注册事件都不同，不需要on）</li>
<li>需要事件进行处理的函数</li>
<li>一个布尔值，表示（true，在捕获阶段调用事件处理函数）（false，在冒泡阶段调用事件处理函数）</li>
</ul>
<blockquote>
<p>一般情况下第三个参数都填false</p>
</blockquote>
<p>IE浏览器对应的两个方法，attachEvent，detachEvent，它们只有冒泡，事件名要加上on。</p>
<h3 id="事件对象"><a href="#事件对象" class="headerlink" title="事件对象"></a>事件对象</h3><p>在注册完事件处理程序后，事件的一个比较重要的对象必须要理解，<strong>event事件对象</strong>。</p>
<p>一般来说，这个对象中包含着所有与当前元素所监听的事件有关的信息，比如元素监听的事件类型，元素本身等等。</p>
<p><strong>比较重要的属性和方法（只读）</strong></p>
<ul>
<li>currentTarget 真正监听事件的那个元素</li>
<li>target 事件的目标元素</li>
<li>type 事件的类型</li>
<li>perventDefault()  取消事件的默认行为</li>
<li>stopPropagation()  取消事件的捕获或者冒泡</li>
<li>bubbles 事件是否冒泡</li>
<li>eventPhase 事件处理程序的三个阶段，1捕获2处于目标3冒泡</li>
</ul>
<p><strong>比较重要的属性和方法（读写）</strong></p>
<ul>
<li>clientX 鼠标在窗口中的水平位置</li>
<li>clientY 鼠标在窗口中的垂直位置</li>
</ul>
<h3 id="事件类型"><a href="#事件类型" class="headerlink" title="事件类型"></a>事件类型</h3><blockquote>
<p>PC端主要是针对鼠标，移动端则是触摸，手势相关的处理</p>
</blockquote>
<p>如果在PC端上发生一次click事件，实际上它是发生了三次事件，mousedown当鼠标按下的时候，mouseup当用户放开的时候，click两个加起来就发生了一次click事件。相对于移动，PC上的鼠标事件非常的丰富，例如mouseover当鼠标首次移入一个元素边界时触发，mouseout当鼠标移出元素时触发，这个移出，到子元素上也会触发这个事件，mousemove当鼠标在元素内移动时重复触发。</p>
<p>总体来说对于文档加载，表单控件，窗口大小改变等事件，比如获取焦点，在失去或者获取焦点是值改变等移动上都是一样的，focus（获得焦点）blur（失去焦点）。</p>
<p>在做一些视差滚动的效果时scroll事件是非常好用，移动上在css中提供了一个类似的属性。</p>
<p>唯一的区别是移动端上没有键盘事件。</p>
<h3 id="移动事件"><a href="#移动事件" class="headerlink" title="移动事件"></a>移动事件</h3><ul>
<li>touchstart 当手指触摸到屏幕时触发</li>
<li>touchmove 当手指在屏幕上连续滑动时触发</li>
<li>touchend 当手指从屏幕上移开时触发</li>
<li>touchcancel 当系统停止跟踪触摸时触发（这个事件没有确定的触发时间）</li>
</ul>
<p>它们都是冒泡的，也可以取消</p>
<p><strong>三个跟踪触摸事件的属性</strong></p>
<ul>
<li>touches 当前跟踪触摸操作的touch数组，在touchend事件中为空</li>
<li>targetTouchs 特定事件目标的touch数组</li>
<li>ChangedTouches 上次触摸时发生了什么改变的touch数组</li>
</ul>
<p><strong>移动event事件对象</strong></p>
<p>PC上存在的，在移动上也存在，描述上有差异，比如</p>
<ul>
<li>target 触摸的DOM节点目标</li>
<li>pageX 触摸目标在页面中的X坐标</li>
<li>pageY 触摸目标在页面中的Y坐标</li>
</ul>
<p><strong>一些手势</strong></p>
<ul>
<li>gesturestart 当一个手指按在屏幕上另外一个手指又触摸屏幕时触发</li>
<li>gesturechange 依赖前者当其中的一个手指发生改变时触发</li>
<li>gestureend 当任何一个手指离开时触发</li>
</ul>
<p><strong>移动手势干货三部曲</strong></p>
<ul>
<li><a href="http://www.cnblogs.com/pifoo/archive/2011/05/23/webkit-touch-event-1.html" target="_blank" rel="external">对于Touch的处理</a></li>
<li><a href="http://www.cnblogs.com/pifoo/archive/2011/05/22/webkit-touch-event-2.html" target="_blank" rel="external">处理简单手势</a></li>
<li><a href="http://www.cnblogs.com/pifoo/archive/2011/05/22/webkit-touch-event-3.html" target="_blank" rel="external">处理复杂手势</a></li>
</ul>
<h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>现在的前端开发了解JS还是仅仅不够的，你需要多方面扩展。</p>
<p>访问<a href="https://github.com/mulgore/Front-End-Develop-Guide" target="_blank" rel="external">Front-End-Develop-Guide</a>项目，资料已准备齐全。</p>

        
        </div>
        <footer class="article-footer">
            <div class="share-container">

    <div class="jiathis_style">
    <span class="jiathis_txt">分享到：</span>
    <a class="jiathis_button_qzone">QQ空间</a>
    <a class="jiathis_button_tsina">新浪微博</a>
    <a class="jiathis_button_tqq">腾讯微博</a>
    <a class="jiathis_button_weixin">微信</a>
    <a href="http://www.jiathis.com/share" class="jiathis jiathis_txt jiathis_separator jtico jtico_jiathis" target="_blank">更多</a>
    <a class="jiathis_counter_style"></a>
</div>
<script type="text/javascript" src="http://v3.jiathis.com/code/jia.js" charset="utf-8"></script>
<style>
    .jiathis_style div:first-child:not(.jiadiv_01) {
        width: auto !important;
        border: none !important;
    }
    .jiathis_style .jiadiv_01 {
        margin: 10px 0;
        border-radius: 4px;
        border: #e1e1e1 solid 1px;
    }
    .jiathis_style .jiadiv_01 div:first-child {
        display: none;
    }
    .jiathis_style .jiadiv_02 {
        padding: 7px 0 !important;
    }
    .jiathis_style .jiadiv_02 .jiatitle {
        width: 85px;
        border: none;
        height: auto;
        margin: 3px 10px;
        padding: 6px 10px;
        border-radius: 4px;
    }
    .jiathis_style .jiadiv_02 .jiatitle:hover {
        border: none;
    }
    .jiathis_style .jiadiv_02 .jiatitle:nth-child(even) {
        margin-left: 0;
    }
    .jiathis_style .jtico:hover {
        opacity: 1;
    }
    .jiathis_style .ckepopBottom,
    .jiathis_style .centerBottom {
        width: auto !important;
        padding: 5px;
        background: #f7f7f7;
    }
</style>



</div>

            
    
        <a href="https://mulgore.github.io/2015/12/16/javascript-learn/#comments" class="article-comment-link ds-thread-count" data-thread-key="https://mulgore.github.io/2015/12/16/javascript-learn/">评论</a>
    

        </footer>
    </div>
    
</article>



    <article id="post-swift-networking" class="article article-type-post" itemscope itemprop="blogPost">
    <div class="article-inner">
        
        
        
            <header class="article-header">
                
    
        <h1 itemprop="name">
            <a class="article-title" href="/2015/12/14/swift-networking/">Swift处理网络请求</a>
        </h1>
    

                <div class="article-meta">
                    
    <div class="article-date">
        <i class="fa fa-calendar"></i>
        <a href="/2015/12/14/swift-networking/">
            <time datetime="2015-12-14T03:38:29.000Z" itemprop="datePublished">2015-12-14</time>
        </a>
    </div>


                    
                    
    <div class="article-tag">
        <i class="fa fa-tag"></i>
        <a class="tag-link" href="/tags/Swift/">Swift</a>
    </div>

                </div>
            </header>
        
        <div class="article-entry" itemprop="articleBody">
        
            
            <p>iOS 7.0之后，推荐使用NSURLSession，所以以下网络请求的处理皆是使用NSURLSession来处理。</p>
<p><strong>如果是Xcode7.0之后，想访问HTTP，需要在info.plist中设置App Transport Security Settings下的Allow Arbitrary Loads为YES</strong></p>
<p><strong>如果你想使用细粒度的NSURLSession，那么你就需要与Delegate进行交互了，例子皆是使用闭包的方式实现</strong></p>
<p>NSURLSession提供如下功能：</p>
<ul>
<li>通过URL将数据下载到内存</li>
<li>通过URL将数据下载到文件系统</li>
<li>将数据上传到指定的URL</li>
<li>在后台完成上述功能</li>
</ul>
<p>NSURLSession的工作模式：</p>
<ul>
<li>一般模式default，可以使用缓存的Cache，Cookie等</li>
<li>不使用缓存模式ephemeral，不使用缓存的Cache，Cookie，权限验证等</li>
<li>后台模式background，在后台完成上传下载</li>
</ul>
<p><strong>如果需要使用POST，那么你就需要使用NSMutableURLRequest，来设置HTTPMethod或HTTPBody</strong></p>
<p><strong>如果使用后台工作模式，那么你将需要与ApplicationDelegate进行交互。</strong></p>
<p>如果你有Node.js的使用经验，我已经为你准备好了一个简单的服务器，可访问<a href="https://github.com/icepy/_posts/blob/master/demo/NSURLSession/service.js" target="_blank" rel="external">https://github.com/icepy/_posts/blob/master/demo/NSURLSession/service.js</a></p>
<p>详细的Demo例子，可访问<a href="https://github.com/icepy/_posts/tree/master/demo/NSURLSession/NSURLSession" target="_blank" rel="external">https://github.com/icepy/_posts/tree/master/demo/NSURLSession/NSURLSession</a></p>
<h2 id="NSURLSession交互图"><a href="#NSURLSession交互图" class="headerlink" title="NSURLSession交互图"></a>NSURLSession交互图</h2><p><img src="https://raw.githubusercontent.com/icepy/_posts/master/img/NSURLSession.jpg" alt="NSURLSession交互图"></p>
<h2 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h2><p><strong>普通的GET请求：</strong></p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> requets:<span class="type">NSURLRequest</span> = <span class="type">NSURLRequest</span>(<span class="type">URL</span>: <span class="keyword">self</span>.url)</span><br><span class="line"><span class="keyword">let</span> configuration:<span class="type">NSURLSessionConfiguration</span> = <span class="type">NSURLSessionConfiguration</span>.defaultSessionConfiguration()</span><br><span class="line"><span class="keyword">let</span> session:<span class="type">NSURLSession</span> = <span class="type">NSURLSession</span>(configuration: configuration)</span><br><span class="line"><span class="keyword">let</span> task:<span class="type">NSURLSessionDataTask</span> = session.dataTaskWithRequest(requets, completionHandler: &#123;</span><br><span class="line">    [<span class="keyword">unowned</span> <span class="keyword">self</span>](data:<span class="type">NSData</span>?,response:<span class="type">NSURLResponse</span>?,error:<span class="type">NSError</span>?)-&gt;<span class="type">Void</span> <span class="keyword">in</span></span><br><span class="line">       <span class="keyword">if</span> error == <span class="literal">nil</span>&#123;</span><br><span class="line">         <span class="keyword">do</span>&#123;</span><br><span class="line">             <span class="keyword">let</span> responseData:<span class="type">NSDictionary</span> = <span class="keyword">try</span> <span class="type">NSJSONSerialization</span>.<span class="type">JSONObjectWithData</span>(data!, options: <span class="type">NSJSONReadingOptions</span>.<span class="type">AllowFragments</span>) <span class="keyword">as</span>! <span class="type">NSDictionary</span></span><br><span class="line">             <span class="built_in">print</span>(<span class="string">"普通GET请求 --- &gt; \(responseData)"</span>)</span><br><span class="line">        &#125;<span class="keyword">catch</span>&#123;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">&#125;)</span><br><span class="line">task.resume()</span><br></pre></td></tr></table></figure>
<p><strong>设置头以及带参数的GET请求：</strong></p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> url:<span class="type">NSURL</span> = <span class="type">NSURL</span>(string: <span class="string">"http://127.0.0.1:8900/add?id=1&amp;session=icepyquery"</span>)!</span><br><span class="line"><span class="keyword">let</span> request:<span class="type">NSMutableURLRequest</span> = <span class="type">NSMutableURLRequest</span>(<span class="type">URL</span>:url)</span><br><span class="line">request.addValue(<span class="string">"ICEPY"</span>, forHTTPHeaderField: <span class="string">"Session-Control-Key"</span>)</span><br><span class="line"><span class="keyword">let</span> configuration:<span class="type">NSURLSessionConfiguration</span> = <span class="type">NSURLSessionConfiguration</span>.defaultSessionConfiguration()</span><br><span class="line"><span class="keyword">let</span> session:<span class="type">NSURLSession</span> = <span class="type">NSURLSession</span>(configuration: configuration)</span><br><span class="line"><span class="keyword">let</span> task:<span class="type">NSURLSessionDataTask</span> = session.dataTaskWithRequest(request, completionHandler: &#123;</span><br><span class="line">    [<span class="keyword">unowned</span> <span class="keyword">self</span>](data:<span class="type">NSData</span>?,response:<span class="type">NSURLResponse</span>?,error:<span class="type">NSError</span>?)-&gt;<span class="type">Void</span> <span class="keyword">in</span></span><br><span class="line">      <span class="keyword">if</span> error == <span class="literal">nil</span>&#123;</span><br><span class="line">         <span class="keyword">do</span>&#123;</span><br><span class="line">            <span class="keyword">let</span> responseData:<span class="type">NSDictionary</span> = <span class="keyword">try</span> <span class="type">NSJSONSerialization</span>.<span class="type">JSONObjectWithData</span>(data!, options: <span class="type">NSJSONReadingOptions</span>.<span class="type">AllowFragments</span>) <span class="keyword">as</span>! <span class="type">NSDictionary</span></span><br><span class="line">            <span class="built_in">print</span>(<span class="string">"普通带头与参数的GET请求 --- &gt; \(responseData)"</span>)</span><br><span class="line">         &#125;<span class="keyword">catch</span>&#123;</span><br><span class="line"></span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line">&#125;)</span><br><span class="line">task.resume()</span><br></pre></td></tr></table></figure>
<p><strong>设置头以及带参数的POST请求：</strong></p>
<p>如果不想设置头可以不要使用<code>addValue方法</code>，参数必须设置在<code>HTTPBody</code>中。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> request:<span class="type">NSMutableURLRequest</span> = <span class="type">NSMutableURLRequest</span>(<span class="type">URL</span>: <span class="keyword">self</span>.url)</span><br><span class="line">request.<span class="type">HTTPMethod</span> = <span class="string">"POST"</span></span><br><span class="line"><span class="keyword">do</span>&#123;</span><br><span class="line">    <span class="keyword">let</span> data:<span class="type">NSData</span> = <span class="keyword">try</span> <span class="type">NSJSONSerialization</span>.dataWithJSONObject(<span class="type">NSDictionary</span>(object: <span class="string">"icepy"</span>, forKey: <span class="string">"name"</span>), options: <span class="type">NSJSONWritingOptions</span>.<span class="type">PrettyPrinted</span>)</span><br><span class="line">    request.<span class="type">HTTPBody</span> = data</span><br><span class="line">&#125;<span class="keyword">catch</span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">request.addValue(<span class="string">"wen"</span>, forHTTPHeaderField: <span class="string">"Session-Control-Key"</span>)</span><br><span class="line"><span class="keyword">let</span> configuration:<span class="type">NSURLSessionConfiguration</span> = <span class="type">NSURLSessionConfiguration</span>.defaultSessionConfiguration()</span><br><span class="line"><span class="keyword">let</span> session:<span class="type">NSURLSession</span> = <span class="type">NSURLSession</span>(configuration: configuration)</span><br><span class="line"><span class="keyword">let</span> task:<span class="type">NSURLSessionDataTask</span> = session.dataTaskWithRequest(request, completionHandler: &#123;</span><br><span class="line">    [<span class="keyword">unowned</span> <span class="keyword">self</span>](data:<span class="type">NSData</span>?,response:<span class="type">NSURLResponse</span>?,error:<span class="type">NSError</span>?) -&gt; <span class="type">Void</span> <span class="keyword">in</span></span><br><span class="line">    <span class="keyword">if</span> error == <span class="literal">nil</span>&#123;</span><br><span class="line">        <span class="keyword">do</span>&#123;</span><br><span class="line">            <span class="keyword">let</span> responseData:<span class="type">NSDictionary</span> = <span class="keyword">try</span> <span class="type">NSJSONSerialization</span>.<span class="type">JSONObjectWithData</span>(data!, options: <span class="type">NSJSONReadingOptions</span>.<span class="type">AllowFragments</span>) <span class="keyword">as</span>! <span class="type">NSDictionary</span></span><br><span class="line">            <span class="built_in">print</span>(<span class="string">"普通空的POST请求 --- &gt; \(responseData)"</span>)</span><br><span class="line">        &#125;<span class="keyword">catch</span>&#123;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line">task.resume()</span><br></pre></td></tr></table></figure>
<p><strong>下载：</strong></p>
<p>下载的处理，稍微有些不同，NSURLSession的DownloadTask会将下载的内容下载在临时temp目录，下载完成之后需要将内容从临时目录移动到你的保存目录，在移动之前还需要去判断一下是否已经存在，如果已经存在需要先删除。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> url:<span class="type">NSURL</span> = <span class="type">NSURL</span>(string: <span class="string">"http://content.battlenet.com.cn/wow/media/screenshots/screenshot-of-the-day/warlords-of-draenor/warlords-of-draenor-ss0420-large.jpg"</span>)!</span><br><span class="line"><span class="keyword">let</span> request:<span class="type">NSURLRequest</span> = <span class="type">NSURLRequest</span>(<span class="type">URL</span>: url)</span><br><span class="line"><span class="keyword">let</span> configuration:<span class="type">NSURLSessionConfiguration</span> = <span class="type">NSURLSessionConfiguration</span>.defaultSessionConfiguration()</span><br><span class="line"><span class="keyword">let</span> session:<span class="type">NSURLSession</span> = <span class="type">NSURLSession</span>(configuration: configuration)</span><br><span class="line"><span class="keyword">let</span> task = session.downloadTaskWithRequest(request, completionHandler: &#123;</span><br><span class="line">    [<span class="keyword">unowned</span> <span class="keyword">self</span>](location:<span class="type">NSURL</span>?,response:<span class="type">NSURLResponse</span>?,error:<span class="type">NSError</span>?) -&gt; <span class="type">Void</span> <span class="keyword">in</span></span><br><span class="line">    <span class="keyword">if</span> error == <span class="literal">nil</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">let</span> fromPath = location!.path&#123;</span><br><span class="line">            <span class="keyword">let</span> file:<span class="type">NSString</span> = docDirPath.stringByAppendingPathComponent(<span class="string">"wow.png"</span>)</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">self</span>.removeFile()&#123;</span><br><span class="line">                <span class="keyword">do</span>&#123;</span><br><span class="line">                    <span class="keyword">try</span> <span class="keyword">self</span>.manager.moveItemAtPath(fromPath, toPath: file <span class="keyword">as</span> <span class="type">String</span>)</span><br><span class="line">                    dispatch_async(dispatch_get_main_queue(), &#123;</span><br><span class="line">                        [<span class="keyword">unowned</span> <span class="keyword">self</span>] <span class="number">_</span> <span class="keyword">in</span></span><br><span class="line">                        <span class="keyword">self</span>.imageView.image = <span class="type">UIImage</span>(named: file <span class="keyword">as</span> <span class="type">String</span>)</span><br><span class="line">                    &#125;)</span><br><span class="line">                &#125;<span class="keyword">catch</span>&#123;</span><br><span class="line">                    <span class="built_in">print</span>(<span class="string">"移动临时数据到保存目录出错"</span>)</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line">task.resume()</span><br></pre></td></tr></table></figure>
<p>删除的方法：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">func</span> <span class="title">removeFile</span><span class="params">()</span></span> -&gt; <span class="type">Bool</span>&#123;</span><br><span class="line">    <span class="keyword">let</span> file:<span class="type">NSString</span> = docDirPath.stringByAppendingPathComponent(<span class="string">"wow.png"</span>)</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">self</span>.manager.fileExistsAtPath(file <span class="keyword">as</span> <span class="type">String</span>)&#123;</span><br><span class="line">        <span class="keyword">do</span>&#123;</span><br><span class="line">            <span class="keyword">try</span> <span class="keyword">self</span>.manager.removeItemAtPath(file <span class="keyword">as</span> <span class="type">String</span>)</span><br><span class="line">        &#125;<span class="keyword">catch</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>上传：</strong></p>
<p>上传可以使用两种方式来实现</p>
<ul>
<li>NSURLSessionUploadTask</li>
<li>NSURLSessionDataTask</li>
</ul>
<p><code>NSURLSessionUploadTask</code>上传成功之后会下载返回结果，反之<code>NSURLSessionDataTask</code>不会。</p>
<p>POST表单上传：</p>
<p>上传还可以利用POST构造一个HTTP表单来完成，需要注意的是使用正确的上传表单头，以及正确的构造主体。</p>
<pre><code>//multipart/form-data  上传所使用的Content-Type
//image/jpg  上传类型
</code></pre><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> url:<span class="type">NSURL</span> = <span class="type">NSURL</span>(string: <span class="string">"http://pitayaswift.sinaapp.com/pitaya.php"</span>)!</span><br><span class="line"><span class="comment">//模拟表单提交</span></span><br><span class="line"><span class="keyword">let</span> request:<span class="type">NSMutableURLRequest</span> = <span class="type">NSMutableURLRequest</span>(<span class="type">URL</span>:url)</span><br><span class="line">request.<span class="type">HTTPMethod</span> = <span class="string">"POST"</span></span><br><span class="line">request.addValue(<span class="string">"Content-Type"</span>, forHTTPHeaderField: <span class="string">"multipart/form-data; boundary=\(boundary)"</span>)</span><br><span class="line">request.<span class="type">HTTPBody</span> = <span class="keyword">self</span>.setRequestFile(request)</span><br><span class="line"><span class="keyword">let</span> configuration:<span class="type">NSURLSessionConfiguration</span> = <span class="type">NSURLSessionConfiguration</span>.defaultSessionConfiguration()</span><br><span class="line"><span class="keyword">let</span> session:<span class="type">NSURLSession</span> = <span class="type">NSURLSession</span>(configuration: configuration)</span><br><span class="line"><span class="keyword">let</span> task:<span class="type">NSURLSessionDataTask</span> = session.dataTaskWithRequest(request, completionHandler: &#123;</span><br><span class="line">    [<span class="keyword">unowned</span> <span class="keyword">self</span>](data:<span class="type">NSData</span>?,response:<span class="type">NSURLResponse</span>?,error:<span class="type">NSError</span>?) -&gt; <span class="type">Void</span> <span class="keyword">in</span></span><br><span class="line">        <span class="built_in">print</span>(error)</span><br><span class="line">&#125;)</span><br><span class="line">task.resume()</span><br></pre></td></tr></table></figure>
<p>构造主体方法：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">func</span> <span class="title">setRequestFile</span><span class="params">(request:NSMutableURLRequest)</span></span>-&gt; <span class="type">NSData</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> header = request.allHTTPHeaderFields</span><br><span class="line">    <span class="keyword">let</span> body = <span class="type">NSMutableData</span>()</span><br><span class="line">    <span class="keyword">let</span> fileType:<span class="type">STFType</span> = <span class="type">STFType</span>(name: <span class="string">"logo"</span>, type: <span class="string">"jpg"</span>)</span><br><span class="line">    <span class="keyword">let</span> codeName:<span class="type">String</span> = <span class="string">"file"</span></span><br><span class="line">    <span class="keyword">let</span> fileUrl:<span class="type">String</span>? =  <span class="type">NSBundle</span>.mainBundle().pathForResource(fileType.fileName, ofType:fileType.fileType)</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">let</span> contentType:<span class="type">AnyObject</span> = header![<span class="string">"Content-Type"</span>]&#123;</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"set Content-Type --- \(contentType)"</span>)</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"set Content-Type --- empty"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">let</span> <span class="type">STFileParams</span>:[<span class="type">STFile</span>] = [<span class="type">STFile</span>(name: codeName, url: fileUrl,data:<span class="literal">nil</span>)]</span><br><span class="line">    <span class="keyword">for</span> file:<span class="type">STFile</span> <span class="keyword">in</span> <span class="type">STFileParams</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> file.fileData == <span class="literal">nil</span>&#123;</span><br><span class="line">            body.appendData(<span class="string">"--\(boundary)\r\n"</span>.<span class="type">STNSData</span>)</span><br><span class="line">            <span class="keyword">let</span> _fileURL = <span class="type">NSURL</span>(fileURLWithPath: file.fileURL!)</span><br><span class="line">            body.appendData(<span class="string">"Content-Disposition: form-data; name=\"\(file.fileName)\"; filename=\"\(_fileURL.lastPathComponent)\"\r\n\r\n"</span>.<span class="type">STNSData</span>)</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">let</span> fileData = <span class="type">NSData</span>(contentsOfFile: file.fileURL!)&#123;</span><br><span class="line">                body.appendData(fileData)</span><br><span class="line">                body.appendData(<span class="string">"\r\n"</span>.<span class="type">STNSData</span>)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            body.appendData(file.fileData!)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    body.appendData(<span class="string">"--\(boundary)--\r\n"</span>.<span class="type">STNSData</span>)</span><br><span class="line">    <span class="keyword">return</span> body</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="留给大家一个小题目"><a href="#留给大家一个小题目" class="headerlink" title="留给大家一个小题目"></a>留给大家一个小题目</h2><p>如何使用<code>NSURLSessionUploadTask</code>来实现上传</p>

        
        </div>
        <footer class="article-footer">
            <div class="share-container">

    <div class="jiathis_style">
    <span class="jiathis_txt">分享到：</span>
    <a class="jiathis_button_qzone">QQ空间</a>
    <a class="jiathis_button_tsina">新浪微博</a>
    <a class="jiathis_button_tqq">腾讯微博</a>
    <a class="jiathis_button_weixin">微信</a>
    <a href="http://www.jiathis.com/share" class="jiathis jiathis_txt jiathis_separator jtico jtico_jiathis" target="_blank">更多</a>
    <a class="jiathis_counter_style"></a>
</div>
<script type="text/javascript" src="http://v3.jiathis.com/code/jia.js" charset="utf-8"></script>
<style>
    .jiathis_style div:first-child:not(.jiadiv_01) {
        width: auto !important;
        border: none !important;
    }
    .jiathis_style .jiadiv_01 {
        margin: 10px 0;
        border-radius: 4px;
        border: #e1e1e1 solid 1px;
    }
    .jiathis_style .jiadiv_01 div:first-child {
        display: none;
    }
    .jiathis_style .jiadiv_02 {
        padding: 7px 0 !important;
    }
    .jiathis_style .jiadiv_02 .jiatitle {
        width: 85px;
        border: none;
        height: auto;
        margin: 3px 10px;
        padding: 6px 10px;
        border-radius: 4px;
    }
    .jiathis_style .jiadiv_02 .jiatitle:hover {
        border: none;
    }
    .jiathis_style .jiadiv_02 .jiatitle:nth-child(even) {
        margin-left: 0;
    }
    .jiathis_style .jtico:hover {
        opacity: 1;
    }
    .jiathis_style .ckepopBottom,
    .jiathis_style .centerBottom {
        width: auto !important;
        padding: 5px;
        background: #f7f7f7;
    }
</style>



</div>

            
    
        <a href="https://mulgore.github.io/2015/12/14/swift-networking/#comments" class="article-comment-link ds-thread-count" data-thread-key="https://mulgore.github.io/2015/12/14/swift-networking/">评论</a>
    

        </footer>
    </div>
    
</article>



    <article id="post-swift-datetime" class="article article-type-post" itemscope itemprop="blogPost">
    <div class="article-inner">
        
        
        
            <header class="article-header">
                
    
        <h1 itemprop="name">
            <a class="article-title" href="/2015/12/05/swift-datetime/">Swift日期处理</a>
        </h1>
    

                <div class="article-meta">
                    
    <div class="article-date">
        <i class="fa fa-calendar"></i>
        <a href="/2015/12/05/swift-datetime/">
            <time datetime="2015-12-05T03:39:20.000Z" itemprop="datePublished">2015-12-05</time>
        </a>
    </div>


                    
                    
    <div class="article-tag">
        <i class="fa fa-tag"></i>
        <a class="tag-link" href="/tags/Swift/">Swift</a>
    </div>

                </div>
            </header>
        
        <div class="article-entry" itemprop="articleBody">
        
            
            <p>在软件开发领域，使用频率比较高的我想日期正是其中之一。以前在Objectice-C中可以使用NSDate，NSDateFormatter类来处理日期，换到Swift中也是一样，<code>唯一需要注意的是iOS中没有毫秒，所有的日期类最小精度只能到秒</code>。</p>
<p><strong>NSDate</strong></p>
<p>NSDate类提供了创建date，比较date以及计算两个date之间间隔的功能，Date对象是不可改变的。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> now = <span class="type">NSDate</span>()</span><br><span class="line"><span class="built_in">print</span>(<span class="string">"现在的时间：\(now)"</span>)</span><br></pre></td></tr></table></figure>
<p>如果你需要与当前日期不同的日期，也可以通过<code>timeIntervalSinceNow</code>和<code>dateByAddingTimeInterval</code>来创建。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> perDay:<span class="type">NSTimeInterval</span> = <span class="number">24</span>*<span class="number">60</span>*<span class="number">60</span></span><br><span class="line"><span class="keyword">let</span> tomorrow = <span class="type">NSDate</span>(timeIntervalSinceNow: perDay)</span><br><span class="line"><span class="keyword">let</span> _tomorrow = now.dateByAddingTimeInterval(perDay)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">"明天的时间：\(tomorrow)"</span>)</span><br><span class="line"><span class="keyword">let</span> yesterday = <span class="type">NSDate</span>(timeIntervalSinceNow: -perDay)</span><br><span class="line"><span class="comment">//增加时间间隔</span></span><br><span class="line"><span class="keyword">let</span> _yesterday = now.dateByAddingTimeInterval(-perDay)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">"昨天的时间：\(yesterday)"</span>)</span><br></pre></td></tr></table></figure>
<p>如果你需要比较两个日，最常用的是使用<code>timeIntervalSinceDate</code>方法。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//比较时间，如果两个时间间隔小于一分钟，可认为在同一天</span></span><br><span class="line"><span class="keyword">if</span> tomorrow.timeIntervalSinceDate(yesterday) &lt; <span class="number">60</span> &#123;</span><br><span class="line">      <span class="comment">//相等</span></span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">     <span class="comment">//不相等</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果你想精度更高的进行比较，那么可以使用：</p>
<ul>
<li><code>tomorrow.isEqualToDate(&lt;#T##otherDate: NSDate##NSDate#&gt;)</code></li>
<li><code>tomorrow.compare(&lt;#T##other: NSDate##NSDate#&gt;)</code></li>
<li><code>tomorrow.laterDate(&lt;#T##anotherDate: NSDate##NSDate#&gt;)</code></li>
<li><code>tomorrow.earlierDate(&lt;#T##anotherDate: NSDate##NSDate#&gt;)</code></li>
</ul>
<p><strong>NSDateFormatter</strong></p>
<p>NSDate本身并不能输出或者格式化，需要借助NSDateFormatter来进行处理，NSDateFormatter的初始化是一个比较消耗的创建，所以一般都要懒加载来处理它。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">lazy</span> <span class="keyword">var</span> dateFormatter = &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="type">NSDateFormatter</span>()</span><br><span class="line">&#125;()</span><br></pre></td></tr></table></figure>
<p>从程序的一般逻辑来看，formatter可以看做是（输入｜输出）的关系，所以NSDateFormatter中供给的方法大部分都是设置属性，获取NSDate对象。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> location = <span class="type">NSLocale</span>(localeIdentifier: <span class="string">"zh-CN"</span>)</span><br><span class="line"><span class="keyword">let</span> timeString = <span class="string">"20110826134106"</span></span><br><span class="line"><span class="keyword">self</span>.dateFormatter.locale = location</span><br><span class="line"><span class="keyword">self</span>.dateFormatter.dateFormat = <span class="string">"yyyyMMddHHmmss"</span></span><br><span class="line"><span class="keyword">let</span> date:<span class="type">NSDate</span> = <span class="keyword">self</span>.dateFormatter.dateFromString(timeString)!</span><br><span class="line"><span class="built_in">print</span>(date)</span><br></pre></td></tr></table></figure>
<p>NSLocale可以设置本地化时间，然后将格式化字符串设置给dateFormat，就可以使用了。</p>
<p><strong>NSCalendar &amp; NSDateComponents</strong></p>
<p>NSCalendar定义了不同的日历，包括佛教历，格里高利历等（这些都与系统提供的本地化设置相关）而<br>NSDateComponents则是定义了一个日期对象的组件，包括<code>年，月，日，小时，分钟，秒</code>等等，另外NSDateComponents也可以去获取时间（比如计算跟某某时间相差多少时间）</p>
<p>初始化NSCalendar，需要注意的是iOS8.0之后，标识开始要使用NSCalendarIdentifier（xxxx）了</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> calendar = <span class="type">NSCalendar</span>(calendarIdentifier: <span class="type">NSCalendarIdentifierGregorian</span>)</span><br></pre></td></tr></table></figure>
<p>初始化NSDateComponents</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> components = <span class="type">NSDateComponents</span>()</span><br><span class="line">components.year = <span class="number">2105</span></span><br><span class="line">components.month = <span class="number">12</span></span><br><span class="line">components.day = <span class="number">5</span></span><br></pre></td></tr></table></figure>
<p>获取某个时间的相差值，需要注意的是，iOS8.0开始要使用NSCalendarUnitYear了，原来的NSYearCalendarUnit将要废弃。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> calendar = <span class="type">NSCalendar</span>(calendarIdentifier: <span class="type">NSCalendarIdentifierGregorian</span>)</span><br><span class="line"><span class="keyword">let</span> unitF:<span class="type">NSCalendarUnit</span> = [<span class="type">NSCalendarUnit</span>.<span class="type">Year</span>,<span class="type">NSCalendarUnit</span>.<span class="type">Month</span>,<span class="type">NSCalendarUnit</span>.<span class="type">Day</span>,<span class="type">NSCalendarUnit</span>.<span class="type">Hour</span>,<span class="type">NSCalendarUnit</span>.<span class="type">Minute</span>,<span class="type">NSCalendarUnit</span>.<span class="type">Second</span>]</span><br><span class="line"><span class="keyword">let</span> dateComponents:<span class="type">NSDateComponents</span>? = calendar?.components(unitF, fromDate: now, toDate: yesterday, options: .<span class="type">MatchNextTimePreservingSmallerUnits</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">"年：\(dateComponents?.year)"</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">"月：\(dateComponents?.month)"</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">"日：\(dateComponents?.day)"</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">"小时：\(dateComponents?.hour)"</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">"分钟：\(dateComponents?.minute)"</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">"秒：\(dateComponents?.second)"</span>)</span><br></pre></td></tr></table></figure>

        
        </div>
        <footer class="article-footer">
            <div class="share-container">

    <div class="jiathis_style">
    <span class="jiathis_txt">分享到：</span>
    <a class="jiathis_button_qzone">QQ空间</a>
    <a class="jiathis_button_tsina">新浪微博</a>
    <a class="jiathis_button_tqq">腾讯微博</a>
    <a class="jiathis_button_weixin">微信</a>
    <a href="http://www.jiathis.com/share" class="jiathis jiathis_txt jiathis_separator jtico jtico_jiathis" target="_blank">更多</a>
    <a class="jiathis_counter_style"></a>
</div>
<script type="text/javascript" src="http://v3.jiathis.com/code/jia.js" charset="utf-8"></script>
<style>
    .jiathis_style div:first-child:not(.jiadiv_01) {
        width: auto !important;
        border: none !important;
    }
    .jiathis_style .jiadiv_01 {
        margin: 10px 0;
        border-radius: 4px;
        border: #e1e1e1 solid 1px;
    }
    .jiathis_style .jiadiv_01 div:first-child {
        display: none;
    }
    .jiathis_style .jiadiv_02 {
        padding: 7px 0 !important;
    }
    .jiathis_style .jiadiv_02 .jiatitle {
        width: 85px;
        border: none;
        height: auto;
        margin: 3px 10px;
        padding: 6px 10px;
        border-radius: 4px;
    }
    .jiathis_style .jiadiv_02 .jiatitle:hover {
        border: none;
    }
    .jiathis_style .jiadiv_02 .jiatitle:nth-child(even) {
        margin-left: 0;
    }
    .jiathis_style .jtico:hover {
        opacity: 1;
    }
    .jiathis_style .ckepopBottom,
    .jiathis_style .centerBottom {
        width: auto !important;
        padding: 5px;
        background: #f7f7f7;
    }
</style>



</div>

            
    
        <a href="https://mulgore.github.io/2015/12/05/swift-datetime/#comments" class="article-comment-link ds-thread-count" data-thread-key="https://mulgore.github.io/2015/12/05/swift-datetime/">评论</a>
    

        </footer>
    </div>
    
</article>



    <article id="post-swift-runtime" class="article article-type-post" itemscope itemprop="blogPost">
    <div class="article-inner">
        
        
        
            <header class="article-header">
                
    
        <h1 itemprop="name">
            <a class="article-title" href="/2015/11/27/swift-runtime/">Runtime在Swift中的使用</a>
        </h1>
    

                <div class="article-meta">
                    
    <div class="article-date">
        <i class="fa fa-calendar"></i>
        <a href="/2015/11/27/swift-runtime/">
            <time datetime="2015-11-27T03:40:32.000Z" itemprop="datePublished">2015-11-27</time>
        </a>
    </div>


                    
                    
    <div class="article-tag">
        <i class="fa fa-tag"></i>
        <a class="tag-link" href="/tags/Swift/">Swift</a>
    </div>

                </div>
            </header>
        
        <div class="article-entry" itemprop="articleBody">
        
            
            <p><strong>源代码基于 Swift 2.1+ Xcode 7.1.1编写</strong></p>
<p>Runtime让语言具备了灵活的动态特性，关于Runtime的理论知识，可推荐大家阅读：</p>
<ul>
<li><a href="http://yulingtianxia.com/blog/2014/11/05/objective-c-runtime/" target="_blank" rel="external">Objective-c Runtime</a></li>
</ul>
<hr>
<p>在Swift中也可以使用这样的机制，当然<code>extension</code>也为Swift准备了良好的特性可用，然后附上<strong>前人</strong>为我们准备的忠告：<em>请记住仅在不得已的情况下使用runtime。随便修改基础框架或所使用的三方代码是毁掉你的应用的绝佳方法。请务必要小心哦。</em></p>
<p>在Swift中使用Runtime，将不在需要你手动导入<code>objc/runtime.h</code>。</p>
<p><strong>交换两个方法</strong></p>
<p>在学习Objectice-C Runtime的理论知识时，在初始化类或者加载的时候会调用两个方法<code>load&#39;和&#39;initialize</code>。方法交叉过程永远会在 load() 方法中进行，每一个类在加载时只会调用一次 load 方法，但是Swift只会在<code>initialize</code>方法中进行。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">UIViewController</span></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">override</span> <span class="class"><span class="keyword">class</span> <span class="title">func</span> <span class="title">initialize</span>()</span>&#123;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">Static</span></span>&#123;</span><br><span class="line">            <span class="keyword">static</span> <span class="keyword">var</span> token:dispatch_once_t = <span class="number">0</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">self</span> != <span class="type">UIViewController</span>.<span class="keyword">self</span>&#123;</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">        dispatch_once(&amp;<span class="type">Static</span>.token, &#123;</span><br><span class="line">            <span class="number">_</span> <span class="keyword">in</span></span><br><span class="line">            <span class="keyword">let</span> viewDidLoad = class_getInstanceMethod(<span class="keyword">self</span>, <span class="type">Selector</span>(<span class="string">"viewDidLoad"</span>))</span><br><span class="line">            <span class="keyword">let</span> viewDidLoaded = class_getInstanceMethod(<span class="keyword">self</span>, <span class="type">Selector</span>(<span class="string">"viewDidLoaded"</span>))</span><br><span class="line">            method_exchangeImplementations(viewDidLoad,viewDidLoaded)</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">viewDidLoaded</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">self</span>.viewDidLoaded()</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"init --- &gt; \(self)"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>IMP</strong></p>
<p>从Swift2.0开始指向函数的指针可以直接转换为闭包，只不过我们需要为它添加上@convention标注</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typealias</span> _IMP = <span class="meta">@convention</span>(<span class="built_in">c</span>)(id:<span class="type">AnyObject</span>,sel:<span class="type">UnsafeMutablePointer</span>&lt;<span class="type">Selector</span>&gt;)-&gt;<span class="type">AnyObject</span></span><br><span class="line"><span class="keyword">typealias</span> _VIMP = <span class="meta">@convention</span>(<span class="built_in">c</span>)(id:<span class="type">AnyObject</span>,sel:<span class="type">UnsafeMutablePointer</span>&lt;<span class="type">Selector</span>&gt;)-&gt;<span class="type">Void</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">UIViewController</span></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">override</span> <span class="class"><span class="keyword">class</span> <span class="title">func</span> <span class="title">initialize</span>()</span>&#123;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">Static</span></span>&#123;</span><br><span class="line">            <span class="keyword">static</span> <span class="keyword">var</span> token:dispatch_once_t = <span class="number">0</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">self</span> != <span class="type">UIViewController</span>.<span class="keyword">self</span>&#123;</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        dispatch_once(&amp;<span class="type">Static</span>.token, &#123;</span><br><span class="line">            <span class="number">_</span> <span class="keyword">in</span></span><br><span class="line">            <span class="keyword">let</span> viewDidLoad:<span class="type">Method</span> = class_getInstanceMethod(<span class="keyword">self</span>, <span class="type">Selector</span>(<span class="string">"viewDidLoad"</span>))</span><br><span class="line">            <span class="keyword">let</span> viewDidLoad_VIMP:_VIMP = <span class="built_in">unsafeBitCast</span>(method_getImplementation(viewDidLoad),_VIMP.<span class="keyword">self</span>)</span><br><span class="line">            <span class="keyword">let</span> block:<span class="meta">@convention</span>(block)(<span class="type">UnsafeMutablePointer</span>&lt;<span class="type">AnyObject</span>&gt;,<span class="type">UnsafeMutablePointer</span>&lt;<span class="type">Selector</span>&gt;)-&gt;<span class="type">Void</span> = &#123;</span><br><span class="line">                (id,sel) <span class="keyword">in</span></span><br><span class="line">                viewDidLoad_VIMP(id: id.memory, sel: sel)</span><br><span class="line">                <span class="built_in">print</span>(<span class="string">"viewDidLoad func execu over id ---&gt; \(id.memory)"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">let</span> imp:<span class="type">COpaquePointer</span> = imp_implementationWithBlock(<span class="built_in">unsafeBitCast</span>(block, <span class="type">AnyObject</span>.<span class="keyword">self</span>))</span><br><span class="line">            method_setImplementation(viewDidLoad,imp)</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>关联对象</strong></p>
<p>不过貌似，Swift的extension现在可以直接扩展属性，关联对象就比较用的少了。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">UIViewController</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="class"><span class="keyword">struct</span> <span class="title">Associa</span></span>&#123;</span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">var</span> <span class="type">Name</span>:<span class="type">String</span> = <span class="string">"UIStackView_Name"</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> name:<span class="type">String</span>&#123;</span><br><span class="line">        <span class="keyword">get</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> objc_getAssociatedObject(<span class="keyword">self</span>,&amp;<span class="type">Associa</span>.<span class="type">Name</span>) <span class="keyword">as</span>! <span class="type">String</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">set</span>(newValue)&#123;</span><br><span class="line">            objc_setAssociatedObject(<span class="keyword">self</span>, &amp;<span class="type">Associa</span>.<span class="type">Name</span>, newValue <span class="keyword">as</span> <span class="type">String</span>?, objc_AssociationPolicy.<span class="type">OBJC_ASSOCIATION_RETAIN_NONATOMIC</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

        
        </div>
        <footer class="article-footer">
            <div class="share-container">

    <div class="jiathis_style">
    <span class="jiathis_txt">分享到：</span>
    <a class="jiathis_button_qzone">QQ空间</a>
    <a class="jiathis_button_tsina">新浪微博</a>
    <a class="jiathis_button_tqq">腾讯微博</a>
    <a class="jiathis_button_weixin">微信</a>
    <a href="http://www.jiathis.com/share" class="jiathis jiathis_txt jiathis_separator jtico jtico_jiathis" target="_blank">更多</a>
    <a class="jiathis_counter_style"></a>
</div>
<script type="text/javascript" src="http://v3.jiathis.com/code/jia.js" charset="utf-8"></script>
<style>
    .jiathis_style div:first-child:not(.jiadiv_01) {
        width: auto !important;
        border: none !important;
    }
    .jiathis_style .jiadiv_01 {
        margin: 10px 0;
        border-radius: 4px;
        border: #e1e1e1 solid 1px;
    }
    .jiathis_style .jiadiv_01 div:first-child {
        display: none;
    }
    .jiathis_style .jiadiv_02 {
        padding: 7px 0 !important;
    }
    .jiathis_style .jiadiv_02 .jiatitle {
        width: 85px;
        border: none;
        height: auto;
        margin: 3px 10px;
        padding: 6px 10px;
        border-radius: 4px;
    }
    .jiathis_style .jiadiv_02 .jiatitle:hover {
        border: none;
    }
    .jiathis_style .jiadiv_02 .jiatitle:nth-child(even) {
        margin-left: 0;
    }
    .jiathis_style .jtico:hover {
        opacity: 1;
    }
    .jiathis_style .ckepopBottom,
    .jiathis_style .centerBottom {
        width: auto !important;
        padding: 5px;
        background: #f7f7f7;
    }
</style>



</div>

            
    
        <a href="https://mulgore.github.io/2015/11/27/swift-runtime/#comments" class="article-comment-link ds-thread-count" data-thread-key="https://mulgore.github.io/2015/11/27/swift-runtime/">评论</a>
    

        </footer>
    </div>
    
</article>



    <article id="post-swift-uistackview" class="article article-type-post" itemscope itemprop="blogPost">
    <div class="article-inner">
        
        
        
            <header class="article-header">
                
    
        <h1 itemprop="name">
            <a class="article-title" href="/2015/11/23/swift-uistackview/">UIStackView的使用</a>
        </h1>
    

                <div class="article-meta">
                    
    <div class="article-date">
        <i class="fa fa-calendar"></i>
        <a href="/2015/11/23/swift-uistackview/">
            <time datetime="2015-11-23T03:41:35.000Z" itemprop="datePublished">2015-11-23</time>
        </a>
    </div>


                    
                    
    <div class="article-tag">
        <i class="fa fa-tag"></i>
        <a class="tag-link" href="/tags/Swift/">Swift</a>
    </div>

                </div>
            </header>
        
        <div class="article-entry" itemprop="articleBody">
        
            
            <p><strong>源代码基于 Swift 2.1+ Xcode 7.1.1编写</strong></p>
<p>iOS 9 出品快速构建UI界面</p>
<p><code>官方原话：UIStackView 类提供了一个高效的接口用于平铺一行或一列的视图组合。Stack视图使你依靠自动布局的能力，创建用户接口使得可以动态的调整设备朝向、屏幕尺寸及任何可用范围内的变化。</code></p>
<p>其实这里很好理解了，如果用Table来看，无非就是在横向或者竖向进行排列，所以UIStackView就存在了两种不同的类型，我们只需要对UIStackView进行约束布局，设置好它的属性，然后依次将视图添加到UIStackView中，系统会自动帮助我们将UIStackView中添加的视图添加上约束。</p>
<p>还需要了解的一点是被UIStackView管理的视图，第一个是与UIStackView左边界对齐，最后一个是与UIStackView右边界对齐，如果设置了<code>vertical.layoutMarginsRelativeArrangement = true</code>，UIStackView将使用相关的内容和不是边界对齐。</p>
<p>Demo可以查看<a href="https://github.com/icepy/withoutMe/tree/master/UIStackView" target="_blank" rel="external">UIStackView</a> Swift 2.0 Xcode 7.1.1</p>
<p><strong>如何创建UIStackView</strong></p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> vertical:<span class="type">UIStackView</span> =  <span class="type">UIStackView</span>(frame: <span class="type">CGRectZero</span>)</span><br><span class="line">vertical.axis = .<span class="type">Vertical</span></span><br><span class="line">vertical.alignment = .<span class="type">Center</span></span><br><span class="line">vertical.distribution = .<span class="type">FillEqually</span></span><br><span class="line">vertical.spacing = <span class="number">10</span></span><br></pre></td></tr></table></figure>
<p>初始化一个UIStackView，然后设置对齐方式，分布方式以及间隔。</p>
<ul>
<li>alignment 这里可以理解为设置X,Y轴</li>
<li>distribution 这里可以理解为控制高度与宽度</li>
<li>spacing 每个视图互相之间的间隔</li>
</ul>
<p>关于更精准的布局可以访问UIStackViewDistribution和UIStackViewAlignment枚举</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">enum</span> <span class="title">UIStackViewDistribution</span> : <span class="title">Int</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* When items do not fit (overflow) or fill (underflow) the space available</span><br><span class="line">     adjustments occur according to compressionResistance or hugging</span><br><span class="line">     priorities of items, or when that is ambiguous, according to arrangement</span><br><span class="line">     order.</span><br><span class="line">     */</span></span><br><span class="line">    <span class="keyword">case</span> <span class="type">Fill</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Items are all the same size.</span><br><span class="line">     When space allows, this will be the size of the item with the largest</span><br><span class="line">     intrinsicContentSize (along the axis of the stack).</span><br><span class="line">     Overflow or underflow adjustments are distributed equally among the items.</span><br><span class="line">     */</span></span><br><span class="line">    <span class="keyword">case</span> <span class="type">FillEqually</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Overflow or underflow adjustments are distributed among the items proportional</span><br><span class="line">     to their intrinsicContentSizes.</span><br><span class="line">     */</span></span><br><span class="line">    <span class="keyword">case</span> <span class="type">FillProportionally</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Additional underflow spacing is divided equally in the spaces between the items.</span><br><span class="line">     Overflow squeezing is controlled by compressionResistance priorities followed by</span><br><span class="line">     arrangement order.</span><br><span class="line">     */</span></span><br><span class="line">    <span class="keyword">case</span> <span class="type">EqualSpacing</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Equal center-to-center spacing of the items is maintained as much</span><br><span class="line">     as possible while still maintaining a minimum edge-to-edge spacing within the</span><br><span class="line">     allowed area.</span><br><span class="line">        Additional underflow spacing is divided equally in the spacing. Overflow</span><br><span class="line">     squeezing is distributed first according to compressionResistance priorities</span><br><span class="line">     of items, then according to subview order while maintaining the configured</span><br><span class="line">     (edge-to-edge) spacing as a minimum.</span><br><span class="line">     */</span></span><br><span class="line">    <span class="keyword">case</span> <span class="type">EqualCentering</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">enum</span> <span class="title">UIStackViewAlignment</span> : <span class="title">Int</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Align the leading and trailing edges of vertically stacked items</span><br><span class="line">     or the top and bottom edges of horizontally stacked items tightly to the container.</span><br><span class="line">     */</span></span><br><span class="line">    <span class="keyword">case</span> <span class="type">Fill</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Align the leading edges of vertically stacked items</span><br><span class="line">     or the top edges of horizontally stacked items tightly to the relevant edge</span><br><span class="line">     of the container</span><br><span class="line">     */</span></span><br><span class="line">    <span class="keyword">case</span> <span class="type">Leading</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">var</span> <span class="type">Top</span>: <span class="type">UIStackViewAlignment</span> &#123; <span class="keyword">get</span> &#125;</span><br><span class="line">    <span class="keyword">case</span> <span class="type">FirstBaseline</span> <span class="comment">// Valid for horizontal axis only</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Center the items in a vertical stack horizontally</span><br><span class="line">     or the items in a horizontal stack vertically</span><br><span class="line">     */</span></span><br><span class="line">    <span class="keyword">case</span> <span class="type">Center</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Align the trailing edges of vertically stacked items</span><br><span class="line">     or the bottom edges of horizontally stacked items tightly to the relevant</span><br><span class="line">     edge of the container</span><br><span class="line">     */</span></span><br><span class="line">    <span class="keyword">case</span> <span class="type">Trailing</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">var</span> <span class="type">Bottom</span>: <span class="type">UIStackViewAlignment</span> &#123; <span class="keyword">get</span> &#125;</span><br><span class="line">    <span class="keyword">case</span> <span class="type">LastBaseline</span> <span class="comment">// Valid for horizontal axis only</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>这里我没有对vertical设置约束</code>，然后使用<code>addArrangedSubview</code>添加一个button到UIStackView中</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> button:<span class="type">UIButton</span> = <span class="type">UIButton</span>(type: .<span class="type">Custom</span>)</span><br><span class="line">vertical.addArrangedSubview(button)</span><br><span class="line"><span class="comment">//或者使用vertical.insertArrangedSubview(&lt;#T##view: UIView##UIView#&gt;, atIndex: &lt;#T##Int#&gt;)</span></span><br></pre></td></tr></table></figure>
<p>还可以通过<code>arrangedSubviews</code>属性来获取一个UIStackView容器内的所有视图。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vertical.arrangedSubviews</span><br></pre></td></tr></table></figure>
<p><strong>从UIStackView中删除</strong></p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">vertical.removeArrangedSubview(button)</span><br><span class="line">button.removeFromSuperview()</span><br></pre></td></tr></table></figure>
<p><code>removeArrangedSubview</code>只是确保从UIStackView中删除约束，移除出视图还需要调用<code>removeFromSuperview</code>。</p>
<h2 id="实战练习"><a href="#实战练习" class="headerlink" title="实战练习"></a>实战练习</h2><p>个人是忠实的暴雪粉丝，所以这个Demo是一道选择题，喜欢《魔兽世界》么？喜欢会打上一课星，不喜欢就会删除一课星。</p>
<p>且拖动两个UIStackView到storyboard中，竖向排列的UIStackView命名为verticalStackView，横向水平排列的UIStackView命名为horizontalStackView，其约束关系如下：</p>
<p><code>在verticalStackView上按住ctrl键将箭头指向superview</code>，左右相对superview，上相对superview，下相对horizontalStackView。<code>在horizontalStackView上按住ctrl键将键头指向superview</code>，Height设置为110，左右相对superview，上相对于verticalStackView，下相对于superview。</p>
<p>设置其（verticalStackView和horizontalStackView）对应方式：</p>
<ul>
<li>alignment 水平居中 center</li>
<li>distribution fill Equally</li>
<li>Spacing 20</li>
</ul>
<p>然后依次拖动UILabel，UIImageView，UIStackView（横向水平排列），且将第三个UIStackView命名为actionStackView，设置其alignment为center，distribution为Equal Spacing，Spacing为10，拖两个UIButton到actionStackView中。</p>
<p><code>按住ctrl连接两个actions事件出来</code></p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@IBAction</span> <span class="function"><span class="keyword">func</span> <span class="title">linkToWow</span><span class="params">(sender: UIButton)</span></span> &#123;</span><br><span class="line">    <span class="keyword">let</span> starImage:<span class="type">UIImageView</span> = <span class="type">UIImageView</span>(image: <span class="type">UIImage</span>(named: <span class="string">"Star"</span>))</span><br><span class="line">    starImage.contentMode = .<span class="type">ScaleAspectFit</span></span><br><span class="line">    horizontalStackView.addArrangedSubview(starImage)</span><br><span class="line">    <span class="type">UIView</span>.animateWithDuration(<span class="number">0.25</span>, animations: &#123;</span><br><span class="line">         [<span class="keyword">unowned</span> <span class="keyword">self</span>] <span class="number">_</span> <span class="keyword">in</span></span><br><span class="line">         <span class="keyword">self</span>.horizontalStackView.layoutIfNeeded()</span><br><span class="line">     &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@IBAction</span> <span class="function"><span class="keyword">func</span> <span class="title">linkToRemoveWow</span><span class="params">(sender: UIButton)</span></span> &#123;</span><br><span class="line">   <span class="keyword">let</span> lastStar:<span class="type">UIView</span>? = horizontalStackView.arrangedSubviews.last</span><br><span class="line">   <span class="keyword">if</span> <span class="keyword">let</span> removeStart:<span class="type">UIView</span> = lastStar&#123;</span><br><span class="line">       horizontalStackView.removeArrangedSubview(removeStart)</span><br><span class="line">       removeStart.removeFromSuperview()</span><br><span class="line">       <span class="type">UIView</span>.animateWithDuration(<span class="number">0.25</span>, animations: &#123;</span><br><span class="line">            [<span class="keyword">unowned</span> <span class="keyword">self</span>] <span class="number">_</span> <span class="keyword">in</span></span><br><span class="line">            <span class="keyword">self</span>.horizontalStackView.layoutIfNeeded()</span><br><span class="line">       &#125;)</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行看看</p>

        
        </div>
        <footer class="article-footer">
            <div class="share-container">

    <div class="jiathis_style">
    <span class="jiathis_txt">分享到：</span>
    <a class="jiathis_button_qzone">QQ空间</a>
    <a class="jiathis_button_tsina">新浪微博</a>
    <a class="jiathis_button_tqq">腾讯微博</a>
    <a class="jiathis_button_weixin">微信</a>
    <a href="http://www.jiathis.com/share" class="jiathis jiathis_txt jiathis_separator jtico jtico_jiathis" target="_blank">更多</a>
    <a class="jiathis_counter_style"></a>
</div>
<script type="text/javascript" src="http://v3.jiathis.com/code/jia.js" charset="utf-8"></script>
<style>
    .jiathis_style div:first-child:not(.jiadiv_01) {
        width: auto !important;
        border: none !important;
    }
    .jiathis_style .jiadiv_01 {
        margin: 10px 0;
        border-radius: 4px;
        border: #e1e1e1 solid 1px;
    }
    .jiathis_style .jiadiv_01 div:first-child {
        display: none;
    }
    .jiathis_style .jiadiv_02 {
        padding: 7px 0 !important;
    }
    .jiathis_style .jiadiv_02 .jiatitle {
        width: 85px;
        border: none;
        height: auto;
        margin: 3px 10px;
        padding: 6px 10px;
        border-radius: 4px;
    }
    .jiathis_style .jiadiv_02 .jiatitle:hover {
        border: none;
    }
    .jiathis_style .jiadiv_02 .jiatitle:nth-child(even) {
        margin-left: 0;
    }
    .jiathis_style .jtico:hover {
        opacity: 1;
    }
    .jiathis_style .ckepopBottom,
    .jiathis_style .centerBottom {
        width: auto !important;
        padding: 5px;
        background: #f7f7f7;
    }
</style>



</div>

            
    
        <a href="https://mulgore.github.io/2015/11/23/swift-uistackview/#comments" class="article-comment-link ds-thread-count" data-thread-key="https://mulgore.github.io/2015/11/23/swift-uistackview/">评论</a>
    

        </footer>
    </div>
    
</article>



    <article id="post-swift-lazy" class="article article-type-post" itemscope itemprop="blogPost">
    <div class="article-inner">
        
        
        
            <header class="article-header">
                
    
        <h1 itemprop="name">
            <a class="article-title" href="/2015/11/22/swift-lazy/">lazy修饰符</a>
        </h1>
    

                <div class="article-meta">
                    
    <div class="article-date">
        <i class="fa fa-calendar"></i>
        <a href="/2015/11/22/swift-lazy/">
            <time datetime="2015-11-22T03:43:09.000Z" itemprop="datePublished">2015-11-22</time>
        </a>
    </div>


                    
                    
    <div class="article-tag">
        <i class="fa fa-tag"></i>
        <a class="tag-link" href="/tags/Swift/">Swift</a>
    </div>

                </div>
            </header>
        
        <div class="article-entry" itemprop="articleBody">
        
            
            <p><strong>源代码基于 Swift 2.1+ Xcode 7.1.1编写</strong></p>
<p>大家都知道延迟加载或者说延迟初始化是很常用的一个优化方式，因为在构建和生成新的对象时，在运行时分配内存的时候会耗费不少时间，如果初始化的一些对象特别复杂，有大量的计算动作，那么这显然不可忽略了。</p>
<p>为了达到这样的目的，在Objective-C中，我们可以如此进行延迟一个对象的初始化：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">//WebViewBridge.h</span><br><span class="line">//伪代码</span><br><span class="line">@property(nonatomic, strong) WebViewJavascriptBridge *bridge;</span><br><span class="line"></span><br><span class="line">//WebViewBridge.m</span><br><span class="line">-(WebViewJavascriptBridge *)bridge</span><br><span class="line">&#123;</span><br><span class="line">    if (!_bridge) &#123;</span><br><span class="line">        _bridge = [WebViewJavascriptBridge bridgeForWebView:self.webview webViewDelegate:self handler:^(id data, WVJBResponseCallback responseCallback) &#123;</span><br><span class="line">            responseCallback(@&quot;启动 webview bridge&quot;);</span><br><span class="line">        &#125;];</span><br><span class="line">    &#125;</span><br><span class="line">    return _bridge;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在初始化WebViewBridge对象时，_bridge是个nil，当我首次调用时bridge属性会调用它的getter方法，从逻辑上就可以看出，它会检查_bridge，如果还未初始化，就进行初始化，如果已经初始化，就返回_bridge。</p>
<p>而在Swift中这一逻辑判断减少成了一个修饰符<code>lazy</code>，没错非常简单的完成了延迟初始化。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">lazy</span> <span class="keyword">var</span> bridge:<span class="type">WebViewJavascriptBridge</span> = &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="type">WebViewJavascriptBridge</span>(forWebView: <span class="keyword">self</span>.webview, webViewDelegate: <span class="keyword">self</span>, handler: &#123; (data, <span class="type">WVJBResponseCallback</span>) -&gt; <span class="type">Void</span> <span class="keyword">in</span></span><br><span class="line"></span><br><span class="line">    &#125;)</span><br><span class="line">&#125;()</span><br></pre></td></tr></table></figure>
<p>当然，在Swift中使用lazy还有一些限制，如下：</p>
<ul>
<li>只能声明变量，不能使用let</li>
<li>需要指定变量的类型</li>
<li>显示的执行的这个闭包</li>
</ul>
<p>其实，还有一个非常有意思的特性，标准库中，提供了一组lazy的方法，可以去延迟，比如数组的map，filter等操作</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> data = <span class="number">1</span>...<span class="number">3</span>  </span><br><span class="line"><span class="keyword">let</span> result = data.<span class="built_in">lazy</span>.<span class="built_in">map</span> &#123;  </span><br><span class="line">    (i: <span class="type">Int</span>) -&gt; <span class="type">Int</span> <span class="keyword">in</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"处理 \(i)"</span>)</span><br><span class="line">    <span class="keyword">return</span> i * <span class="number">2</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> result &#123;  </span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"操作后结果为 \(i)"</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">print</span>(<span class="string">"操作结束"</span>)</span><br></pre></td></tr></table></figure>

        
        </div>
        <footer class="article-footer">
            <div class="share-container">

    <div class="jiathis_style">
    <span class="jiathis_txt">分享到：</span>
    <a class="jiathis_button_qzone">QQ空间</a>
    <a class="jiathis_button_tsina">新浪微博</a>
    <a class="jiathis_button_tqq">腾讯微博</a>
    <a class="jiathis_button_weixin">微信</a>
    <a href="http://www.jiathis.com/share" class="jiathis jiathis_txt jiathis_separator jtico jtico_jiathis" target="_blank">更多</a>
    <a class="jiathis_counter_style"></a>
</div>
<script type="text/javascript" src="http://v3.jiathis.com/code/jia.js" charset="utf-8"></script>
<style>
    .jiathis_style div:first-child:not(.jiadiv_01) {
        width: auto !important;
        border: none !important;
    }
    .jiathis_style .jiadiv_01 {
        margin: 10px 0;
        border-radius: 4px;
        border: #e1e1e1 solid 1px;
    }
    .jiathis_style .jiadiv_01 div:first-child {
        display: none;
    }
    .jiathis_style .jiadiv_02 {
        padding: 7px 0 !important;
    }
    .jiathis_style .jiadiv_02 .jiatitle {
        width: 85px;
        border: none;
        height: auto;
        margin: 3px 10px;
        padding: 6px 10px;
        border-radius: 4px;
    }
    .jiathis_style .jiadiv_02 .jiatitle:hover {
        border: none;
    }
    .jiathis_style .jiadiv_02 .jiatitle:nth-child(even) {
        margin-left: 0;
    }
    .jiathis_style .jtico:hover {
        opacity: 1;
    }
    .jiathis_style .ckepopBottom,
    .jiathis_style .centerBottom {
        width: auto !important;
        padding: 5px;
        background: #f7f7f7;
    }
</style>



</div>

            
    
        <a href="https://mulgore.github.io/2015/11/22/swift-lazy/#comments" class="article-comment-link ds-thread-count" data-thread-key="https://mulgore.github.io/2015/11/22/swift-lazy/">评论</a>
    

        </footer>
    </div>
    
</article>



    <article id="post-swift-uialertcontroller" class="article article-type-post" itemscope itemprop="blogPost">
    <div class="article-inner">
        
        
        
            <header class="article-header">
                
    
        <h1 itemprop="name">
            <a class="article-title" href="/2015/11/19/swift-uialertcontroller/">使用UIAlertController</a>
        </h1>
    

                <div class="article-meta">
                    
    <div class="article-date">
        <i class="fa fa-calendar"></i>
        <a href="/2015/11/19/swift-uialertcontroller/">
            <time datetime="2015-11-19T03:44:10.000Z" itemprop="datePublished">2015-11-19</time>
        </a>
    </div>


                    
                    
    <div class="article-tag">
        <i class="fa fa-tag"></i>
        <a class="tag-link" href="/tags/Swift/">Swift</a>
    </div>

                </div>
            </header>
        
        <div class="article-entry" itemprop="articleBody">
        
            
            <p><strong>源代码基于 Swift 2.1+ Xcode 7.1.1编写</strong></p>
<p>在iOS 8中出现了UIAlertController用来替换以前的UIAlertView与UIActionSheet</p>
<p><strong>使用它的好处</strong></p>
<ul>
<li>现在它是一个Controller，意味着可以使用modal或者popover的方式来展示，而且可以从UIViewController的配置属性中获利良多</li>
<li>UIAlertViewController在配置按钮，文本框时更加的灵活</li>
<li>引进了一个新的类UIAlertAction来对按钮的数量，类型，顺序加以控制，比之前更简洁</li>
</ul>
<p>可以下载<a href="https://github.com/icepy/withoutMe/tree/master/UIAlertController" target="_blank" rel="external">Demo</a>来运行，Swift 2.0 Xcode 7.1.1</p>
<p>也可以阅读Apple提供的文档<a href="https://developer.apple.com/library/tvos/documentation/UIKit/Reference/UIAlertController_class/index.html" target="_blank" rel="external">UIAlertController</a></p>
<p><strong>初始化alert与actionSheet</strong></p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">lazy</span> <span class="keyword">var</span> alert:<span class="type">UIAlertController</span> = &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="type">UIAlertController</span>(title: <span class="string">"alert"</span>, message: <span class="string">"魔兽世界7.0－军团再临资料片"</span>, preferredStyle: <span class="type">UIAlertControllerStyle</span>.<span class="type">Alert</span>)</span><br><span class="line">&#125;()</span><br><span class="line"><span class="built_in">lazy</span> <span class="keyword">var</span> actionSheet:<span class="type">UIAlertController</span> = &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="type">UIAlertController</span>(title: <span class="string">"actionSheet"</span>, message: <span class="string">"魔兽世界7.0要塞"</span>, preferredStyle: <span class="type">UIAlertControllerStyle</span>.<span class="type">ActionSheet</span>)</span><br><span class="line">&#125;()</span><br></pre></td></tr></table></figure>
<p>从风格上来看，使用了一个枚举来描述，它所涵盖的类型有两种：</p>
<ul>
<li>Alert 创建一个弹出框</li>
<li>ActionSheet 创建一个上拉菜单</li>
</ul>
<p><strong>创建普通的弹出框</strong></p>
<p>每一个对应的按钮，现在使用UIAlertAction来创建，对应的动作都成了闭包，从阅读上来说是非常线性的，最后用创建好的UIAlertController顺序添加即可。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> closeAlert:<span class="type">UIAlertAction</span> = <span class="type">UIAlertAction</span>(title: <span class="string">"取消"</span>, style: <span class="type">UIAlertActionStyle</span>.<span class="type">Cancel</span>, handler: <span class="literal">nil</span>)</span><br><span class="line"><span class="keyword">let</span> okAlert:<span class="type">UIAlertAction</span> = <span class="type">UIAlertAction</span>(title: <span class="string">"下载"</span>, style: <span class="type">UIAlertActionStyle</span>.<span class="type">Default</span>, handler: <span class="literal">nil</span>)</span><br><span class="line"><span class="keyword">self</span>.alert.addAction(closeAlert)</span><br><span class="line"><span class="keyword">self</span>.alert.addAction(okAlert)</span><br></pre></td></tr></table></figure>
<p>因为现在成了Controller，所以想要显示可以用<code>self.presentViewController(self.alert, animated: true, completion: nil);</code>模态弹出即可。</p>
<p>UIAlertActionStyle提供了三种样式，让我们使用</p>
<ul>
<li>Default 标准样式</li>
<li>Cancel 取消样式</li>
<li>Destructive 警告样式</li>
</ul>
<p><strong>创建带输入框的弹出框</strong></p>
<p>不得不说，Apple给我们提供了一个很鸡肋的东西，那就是<code>addTextFieldWithConfigurationHandler</code></p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">self</span>.alert.addTextFieldWithConfigurationHandler(&#123;</span><br><span class="line">     [<span class="keyword">unowned</span> <span class="keyword">self</span>] (text:<span class="type">UITextField</span>) <span class="keyword">in</span></span><br><span class="line">     text.placeholder = <span class="string">"账户"</span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">self</span>.alert.addTextFieldWithConfigurationHandler(&#123;</span><br><span class="line">     [<span class="keyword">unowned</span> <span class="keyword">self</span>] (text:<span class="type">UITextField</span>) <span class="keyword">in</span></span><br><span class="line">     text.placeholder = <span class="string">"邀请码"</span></span><br><span class="line">     <span class="type">NSNotificationCenter</span>.defaultCenter().addObserver(<span class="keyword">self</span>, selector:<span class="string">"alertTextFieldDidChange:"</span>, name: <span class="type">UITextFieldTextDidChangeNotification</span>, object: text)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">let</span> okAlert:<span class="type">UIAlertAction</span> = <span class="type">UIAlertAction</span>(title: <span class="string">"升级资料片"</span>, style: <span class="type">UIAlertActionStyle</span>.<span class="type">Default</span>, handler: &#123;</span><br><span class="line">     [<span class="keyword">unowned</span> <span class="keyword">self</span>] (action:<span class="type">UIAlertAction</span>) <span class="keyword">in</span></span><br><span class="line">     <span class="type">NSNotificationCenter</span>.defaultCenter().removeObserver(<span class="keyword">self</span>, name: <span class="type">UITextFieldTextDidChangeNotification</span>, object: <span class="literal">nil</span>)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">self</span>.alert.addAction(okAlert)</span><br><span class="line">okAlert.enabled = <span class="literal">false</span></span><br></pre></td></tr></table></figure>
<p>虽然你可以这样使用，但是，你还是自己用UIViewController创建一个这样的界面比较好。</p>
<p><strong>创建一个上拉菜单</strong></p>
<p>从使用上来说，跟之前创建Alert一样，需要使用UIAlertAction来创建每一项菜单。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> cancalAction:<span class="type">UIAlertAction</span> = <span class="type">UIAlertAction</span>(title: <span class="string">"取消"</span>, style: <span class="type">UIAlertActionStyle</span>.<span class="type">Cancel</span>, handler: <span class="literal">nil</span>)</span><br><span class="line"><span class="keyword">let</span> deleteAction:<span class="type">UIAlertAction</span> = <span class="type">UIAlertAction</span>(title: <span class="string">"删除 "</span>, style: <span class="type">UIAlertActionStyle</span>.<span class="type">Destructive</span>, handler: <span class="literal">nil</span>)</span><br><span class="line"><span class="keyword">let</span> archiveAction:<span class="type">UIAlertAction</span> = <span class="type">UIAlertAction</span>(title: <span class="string">"升级"</span>, style: <span class="type">UIAlertActionStyle</span>.<span class="type">Default</span>, handler: <span class="literal">nil</span>)</span><br><span class="line"><span class="keyword">self</span>.actionSheet.addAction(cancalAction)</span><br><span class="line"><span class="keyword">self</span>.actionSheet.addAction(deleteAction)</span><br><span class="line"><span class="keyword">self</span>.actionSheet.addAction(archiveAction)</span><br></pre></td></tr></table></figure>

        
        </div>
        <footer class="article-footer">
            <div class="share-container">

    <div class="jiathis_style">
    <span class="jiathis_txt">分享到：</span>
    <a class="jiathis_button_qzone">QQ空间</a>
    <a class="jiathis_button_tsina">新浪微博</a>
    <a class="jiathis_button_tqq">腾讯微博</a>
    <a class="jiathis_button_weixin">微信</a>
    <a href="http://www.jiathis.com/share" class="jiathis jiathis_txt jiathis_separator jtico jtico_jiathis" target="_blank">更多</a>
    <a class="jiathis_counter_style"></a>
</div>
<script type="text/javascript" src="http://v3.jiathis.com/code/jia.js" charset="utf-8"></script>
<style>
    .jiathis_style div:first-child:not(.jiadiv_01) {
        width: auto !important;
        border: none !important;
    }
    .jiathis_style .jiadiv_01 {
        margin: 10px 0;
        border-radius: 4px;
        border: #e1e1e1 solid 1px;
    }
    .jiathis_style .jiadiv_01 div:first-child {
        display: none;
    }
    .jiathis_style .jiadiv_02 {
        padding: 7px 0 !important;
    }
    .jiathis_style .jiadiv_02 .jiatitle {
        width: 85px;
        border: none;
        height: auto;
        margin: 3px 10px;
        padding: 6px 10px;
        border-radius: 4px;
    }
    .jiathis_style .jiadiv_02 .jiatitle:hover {
        border: none;
    }
    .jiathis_style .jiadiv_02 .jiatitle:nth-child(even) {
        margin-left: 0;
    }
    .jiathis_style .jtico:hover {
        opacity: 1;
    }
    .jiathis_style .ckepopBottom,
    .jiathis_style .centerBottom {
        width: auto !important;
        padding: 5px;
        background: #f7f7f7;
    }
</style>



</div>

            
    
        <a href="https://mulgore.github.io/2015/11/19/swift-uialertcontroller/#comments" class="article-comment-link ds-thread-count" data-thread-key="https://mulgore.github.io/2015/11/19/swift-uialertcontroller/">评论</a>
    

        </footer>
    </div>
    
</article>



    <article id="post-swift-pointer" class="article article-type-post" itemscope itemprop="blogPost">
    <div class="article-inner">
        
        
        
            <header class="article-header">
                
    
        <h1 itemprop="name">
            <a class="article-title" href="/2015/11/14/swift-pointer/">在Swift中如何使用指针并操作指针</a>
        </h1>
    

                <div class="article-meta">
                    
    <div class="article-date">
        <i class="fa fa-calendar"></i>
        <a href="/2015/11/14/swift-pointer/">
            <time datetime="2015-11-14T03:45:27.000Z" itemprop="datePublished">2015-11-14</time>
        </a>
    </div>


                    
                    
    <div class="article-tag">
        <i class="fa fa-tag"></i>
        <a class="tag-link" href="/tags/Swift/">Swift</a>
    </div>

                </div>
            </header>
        
        <div class="article-entry" itemprop="articleBody">
        
            
            <p><strong>源代码基于 Swift 2.1+ Xcode 7.1.1编写</strong></p>
<p>如果你还不了解指针，请先阅读<a href="http://blog.jobbole.com/25409/" target="_blank" rel="external">C语言指针5分钟教程</a>。</p>
<p>在Swift中指针用两个特殊的类型来描述，UnsafePointer<t>和UnsafeMutablePointer<t>，遵循Cocoa的原则，可以看出<code>不可变</code>与<code>可变</code>的不同，当我们创建指针之后，就可以通过memory来操作指针了。另外，Swift中UnsafeBufferPointer<t>来描述一组连续的数据指针以及非完整结构不透明指针COpaquePointer</t></t></t></p>
<p><strong>在函数中传递指针</strong></p>
<p>在函数中传递指针有两种方式，一：使用<code>inout</code>关键字。二：使用Swift准备的指针类型。区别，我用注释写在具体的例子中。</p>
<p>且先看看<code>inout</code>关键字，如何操作</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> num:<span class="type">Int</span> = <span class="number">10</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">some</span><span class="params">(<span class="keyword">inout</span> numb:Int)</span></span>&#123;</span><br><span class="line">    <span class="comment">//如果使用inout关键字，在函数体内部不需要处理指针类型，可直接操作</span></span><br><span class="line">    numb += <span class="number">1</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"numb --&gt; \(numb)"</span>)</span><br><span class="line">&#125;</span><br><span class="line">some(&amp;num)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">"num ---&gt; \(num)"</span>)</span><br></pre></td></tr></table></figure>
<p>使用Swift准备的指针类型</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> num:<span class="type">Int</span> = <span class="number">10</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">some</span><span class="params">(numb:UnsafeMutablePointer&lt;Int&gt;)</span></span>&#123;</span><br><span class="line">    <span class="comment">//如果使用Swift提供的类型，那么需要使用memory来进行操作</span></span><br><span class="line">    numb.memory += <span class="number">1</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"numb --&gt; \(numb.memory)"</span>)</span><br><span class="line">&#125;</span><br><span class="line">some(&amp;num)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">"num ---&gt; \(num)"</span>)</span><br></pre></td></tr></table></figure>
<p>需要注意的是，Swift中地址符&amp;是不能直接使用的，只能是函数传递时才可用。</p>
<p><strong>如何直接操作</strong></p>
<p>虽然无法像OC或者C中那样直接通过地址符&amp;来操作指针，但是Swift也提供了辅助的方法间接的来帮助我们来操作指针。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> i:<span class="type">Int</span> = <span class="number">10</span></span><br><span class="line">i = <span class="built_in">withUnsafeMutablePointer</span>(&amp;i, &#123;</span><br><span class="line">   (p:<span class="type">UnsafeMutablePointer</span>&lt;<span class="type">Int</span>&gt;) -&gt; <span class="type">Int</span> <span class="keyword">in</span></span><br><span class="line">       p.memory += <span class="number">20</span></span><br><span class="line">       <span class="keyword">return</span> p.memory</span><br><span class="line">&#125;)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">"i value ---&gt; \(i)"</span>)</span><br></pre></td></tr></table></figure>
<p><strong>如何使用指向数组的指针</strong></p>
<p>如果只是函数传递，不可变直接传递，可变使用&amp;符即可，如果想直接操作，那么还是需要UnsafeBufferPointer<t>来辅助完成。</t></p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> array:[<span class="type">Int</span>] = [<span class="number">2</span>,<span class="number">1</span>,<span class="number">3</span>,<span class="number">4</span>]</span><br><span class="line"><span class="keyword">var</span> arrayPtr:<span class="type">UnsafeMutableBufferPointer</span>&lt;<span class="type">Int</span>&gt; = <span class="type">UnsafeMutableBufferPointer</span>&lt;<span class="type">Int</span>&gt;(start: &amp;array, <span class="built_in">count</span>: array.<span class="built_in">count</span>)</span><br><span class="line"><span class="keyword">var</span> baseArrayPtr:<span class="type">UnsafeMutablePointer</span>&lt;<span class="type">Int</span>&gt; = arrayPtr.baseAddress <span class="keyword">as</span> <span class="type">UnsafeMutablePointer</span>&lt;<span class="type">Int</span>&gt;</span><br><span class="line"><span class="keyword">var</span> nextPtr:<span class="type">UnsafeMutablePointer</span>&lt;<span class="type">Int</span>&gt; = baseArrayPtr.successor()</span><br><span class="line"><span class="keyword">var</span> threPtr:<span class="type">UnsafeMutablePointer</span>&lt;<span class="type">Int</span>&gt; = nextPtr.successor()</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">"第一个元素  \(baseArrayPtr.memory)"</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">"第二个元素 \(nextPtr.memory)"</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">"第三个元素  \(threPtr.memory)"</span>)</span><br></pre></td></tr></table></figure>
<p><strong>如何通过指针强制转换类型</strong></p>
<p>这个操作比较危险，除非你明确预期知道类型，不然编译器是无法知道的，也就造成了非常大的不确定性。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr:<span class="type">NSArray</span> = <span class="type">NSArray</span>(object: <span class="string">"icepy"</span>)</span><br><span class="line"><span class="keyword">let</span> str:<span class="type">NSString</span> = <span class="built_in">unsafeBitCast</span>(arr[<span class="number">0</span>],<span class="type">NSString</span>.<span class="keyword">self</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">"str --- &gt; \(str.stringByAppendingPathComponent("</span>app<span class="string">"))"</span>)</span><br></pre></td></tr></table></figure>
<p><strong>创建一个指针</strong></p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建可变指针</span></span><br><span class="line"><span class="keyword">var</span> i:<span class="type">UnsafeMutablePointer</span>&lt;<span class="type">String</span>&gt; = <span class="type">UnsafeMutablePointer</span>&lt;<span class="type">String</span>&gt;.alloc(<span class="number">10</span>)</span><br><span class="line">i.initialize(<span class="string">"icepy"</span>)</span><br></pre></td></tr></table></figure>
<p><strong>内存管理</strong></p>
<p>还有一点要注意的是，如果是属于自己手动创建的指针，Swift是不负责管理内存的，需要手动的销毁与释放。</p>
<p>一个UnsafeMutablePointer内存一般有三个状态：</p>
<ul>
<li>内存没有被分配，null指针</li>
<li>内存进行了分配，且值还未初始化</li>
<li>内存进行了分配，且值已经初始化</li>
</ul>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> i:<span class="type">UnsafeMutablePointer</span>&lt;<span class="type">String</span>&gt; = <span class="type">UnsafeMutablePointer</span>&lt;<span class="type">String</span>&gt;.alloc(<span class="number">10</span>)</span><br><span class="line">i.initialize(<span class="string">"icepy"</span>)        </span><br><span class="line"><span class="built_in">print</span>(<span class="string">"i的内存地址 \(i)"</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">"i的memory \(i.memory)"</span>)        </span><br><span class="line">i.destroy() <span class="comment">//销毁指针指向的对象</span></span><br><span class="line">i.dealloc(<span class="number">10</span>) <span class="comment">//销毁指针申请的内存</span></span><br><span class="line">i = <span class="literal">nil</span></span><br></pre></td></tr></table></figure>

        
        </div>
        <footer class="article-footer">
            <div class="share-container">

    <div class="jiathis_style">
    <span class="jiathis_txt">分享到：</span>
    <a class="jiathis_button_qzone">QQ空间</a>
    <a class="jiathis_button_tsina">新浪微博</a>
    <a class="jiathis_button_tqq">腾讯微博</a>
    <a class="jiathis_button_weixin">微信</a>
    <a href="http://www.jiathis.com/share" class="jiathis jiathis_txt jiathis_separator jtico jtico_jiathis" target="_blank">更多</a>
    <a class="jiathis_counter_style"></a>
</div>
<script type="text/javascript" src="http://v3.jiathis.com/code/jia.js" charset="utf-8"></script>
<style>
    .jiathis_style div:first-child:not(.jiadiv_01) {
        width: auto !important;
        border: none !important;
    }
    .jiathis_style .jiadiv_01 {
        margin: 10px 0;
        border-radius: 4px;
        border: #e1e1e1 solid 1px;
    }
    .jiathis_style .jiadiv_01 div:first-child {
        display: none;
    }
    .jiathis_style .jiadiv_02 {
        padding: 7px 0 !important;
    }
    .jiathis_style .jiadiv_02 .jiatitle {
        width: 85px;
        border: none;
        height: auto;
        margin: 3px 10px;
        padding: 6px 10px;
        border-radius: 4px;
    }
    .jiathis_style .jiadiv_02 .jiatitle:hover {
        border: none;
    }
    .jiathis_style .jiadiv_02 .jiatitle:nth-child(even) {
        margin-left: 0;
    }
    .jiathis_style .jtico:hover {
        opacity: 1;
    }
    .jiathis_style .ckepopBottom,
    .jiathis_style .centerBottom {
        width: auto !important;
        padding: 5px;
        background: #f7f7f7;
    }
</style>



</div>

            
    
        <a href="https://mulgore.github.io/2015/11/14/swift-pointer/#comments" class="article-comment-link ds-thread-count" data-thread-key="https://mulgore.github.io/2015/11/14/swift-pointer/">评论</a>
    

        </footer>
    </div>
    
</article>



    <nav id="page-nav">
        <a class="extend prev" rel="prev" href="/page/2/">&laquo; 上一页</a><a class="page-number" href="/">1</a><a class="page-number" href="/page/2/">2</a><span class="page-number current">3</span><a class="page-number" href="/page/4/">4</a><a class="extend next" rel="next" href="/page/4/">下一页 &raquo;</a>
    </nav>
</section>
            
                <aside id="sidebar">
   
        
    <div class="widget-wrap">
        <h3 class="widget-title">最新文章</h3>
        <div class="widget">
            <ul id="recent-post" class="no-thumbnail">
                
                    <li>
                        
                        <div class="item-inner">
                            <p class="item-category"></p>
                            <p class="item-title"><a href="/2016/06/02/keduo-weekly-1/" class="title">课多周刊第1期</a></p>
                            <p class="item-date"><time datetime="2016-06-02T02:02:25.000Z" itemprop="datePublished">2016-06-02</time></p>
                        </div>
                    </li>
                
                    <li>
                        
                        <div class="item-inner">
                            <p class="item-category"></p>
                            <p class="item-title"><a href="/2016/06/01/used-CNodeAPI-for-development-of-react-webapp/" class="title">基于CNodeAPI使用react开发一个完整的Web应用</a></p>
                            <p class="item-date"><time datetime="2016-06-01T12:39:17.000Z" itemprop="datePublished">2016-06-01</time></p>
                        </div>
                    </li>
                
                    <li>
                        
                        <div class="item-inner">
                            <p class="item-category"></p>
                            <p class="item-title"><a href="/2016/05/23/follow-react-lesson/" class="title">和我一起实战react</a></p>
                            <p class="item-date"><time datetime="2016-05-23T07:24:24.000Z" itemprop="datePublished">2016-05-23</time></p>
                        </div>
                    </li>
                
                    <li>
                        
                        <div class="item-inner">
                            <p class="item-category"></p>
                            <p class="item-title"><a href="/2016/05/16/issues-1/" class="title">我是这样学习前端的</a></p>
                            <p class="item-date"><time datetime="2016-05-16T07:49:38.000Z" itemprop="datePublished">2016-05-16</time></p>
                        </div>
                    </li>
                
                    <li>
                        
                        <div class="item-inner">
                            <p class="item-category"></p>
                            <p class="item-title"><a href="/2016/04/29/FED-Talk4/" class="title">FED-Talk月刊第四期（2016年4月）</a></p>
                            <p class="item-date"><time datetime="2016-04-29T06:00:40.000Z" itemprop="datePublished">2016-04-29</time></p>
                        </div>
                    </li>
                
            </ul>
        </div>
    </div>

    
        
    
        
    <div class="widget-wrap">
        <h3 class="widget-title">归档</h3>
        <div class="widget">
            <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/06/">六月 2016</a><span class="archive-list-count">2</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/05/">五月 2016</a><span class="archive-list-count">2</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/04/">四月 2016</a><span class="archive-list-count">6</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/03/">三月 2016</a><span class="archive-list-count">3</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/02/">二月 2016</a><span class="archive-list-count">3</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/01/">一月 2016</a><span class="archive-list-count">4</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/12/">十二月 2015</a><span class="archive-list-count">5</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/11/">十一月 2015</a><span class="archive-list-count">6</span></li></ul>
        </div>
    </div>

    
        
    <div class="widget-wrap">
        <h3 class="widget-title">标签</h3>
        <div class="widget">
            <ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/JavaScript/">JavaScript</a><span class="tag-list-count">3</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Node-js/">Node.js</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Swift/">Swift</a><span class="tag-list-count">14</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/webpack/">webpack</a><span class="tag-list-count">2</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/前端漫谈/">前端漫谈</a><span class="tag-list-count">3</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/实战课程/">实战课程</a><span class="tag-list-count">2</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/工具/">工具</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/课多周刊/">课多周刊</a><span class="tag-list-count">5</span></li></ul>
        </div>
    </div>

    
        
    <div class="widget-wrap">
        <h3 class="widget-title">标签云</h3>
        <div class="widget tagcloud">
            <a href="/tags/JavaScript/" style="font-size: 15px;">JavaScript</a> <a href="/tags/Node-js/" style="font-size: 10px;">Node.js</a> <a href="/tags/Swift/" style="font-size: 20px;">Swift</a> <a href="/tags/webpack/" style="font-size: 12.5px;">webpack</a> <a href="/tags/前端漫谈/" style="font-size: 15px;">前端漫谈</a> <a href="/tags/实战课程/" style="font-size: 12.5px;">实战课程</a> <a href="/tags/工具/" style="font-size: 10px;">工具</a> <a href="/tags/课多周刊/" style="font-size: 17.5px;">课多周刊</a>
        </div>
    </div>

    
        
    <div class="widget-wrap widget-list">
        <h3 class="widget-title">链接</h3>
        <div class="widget">
            <ul>
                
            </ul>
        </div>
    </div>


    
    <div id="toTop" class="fa fa-angle-up"></div>
</aside>
            
        </div>
        <footer id="footer">
    <div class="outer">
        <div id="footer-info" class="inner">
            &copy; 2016 icepy,yuanxj1024<br>
            Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>. Theme by <a href="http://github.com/ppoffice">PPOffice</a>
        </div>
    </div>
</footer>
        
    
    <script type="text/javascript">
    var duoshuoQuery = {short_name:'icepy'};
    (function() {
    var ds = document.createElement('script');
    ds.type = 'text/javascript';ds.async = true;
    ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
    ds.charset = 'UTF-8';
    (document.getElementsByTagName('head')[0]
    || document.getElementsByTagName('body')[0]).appendChild(ds);
    })();
    </script>



    
        <script src="/vendor/fancybox/jquery.fancybox.pack.js"></script>
    


<!-- Custom Scripts -->
<script src="/js/main.js"></script>

    </div>
</body>
</html>